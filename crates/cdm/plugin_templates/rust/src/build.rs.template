use cdm_plugin_interface::{OutputFile, Schema, Utils, JSON};

/// Generates code from the schema
pub fn build(schema: Schema, config: JSON, utils: &Utils) -> Vec<OutputFile> {
    let mut files = Vec::new();

    // TODO: Implement your build logic here
    // Example: Generate code files based on the schema

    // Access configuration
    let _example_config = config
        .get("example_setting")
        .and_then(|v| v.as_str())
        .unwrap_or("default");

    // Iterate over type aliases
    for (type_name, alias) in schema.type_aliases.iter() {
        // TODO: Generate code for type alias
        eprintln!("Type alias: {}", type_name);
    }

    // Iterate over models
    for (model_name, model) in schema.models.iter() {
        // TODO: Generate code for model
        eprintln!("Model: {}", model_name);

        for field in &model.fields {
            eprintln!("  Field: {} ({:?})", field.name, field.field_type);
        }
    }

    // Example: Create an output file
    files.push(OutputFile {
        path: "output.txt".to_string(),
        content: "Generated by cdm plugin\n".to_string(),
    });

    files
}

#[cfg(test)]
mod tests {
    use super::*;
    use cdm_plugin_interface::{ModelDefinition, TypeAliasDefinition};
    use std::collections::HashMap;

    #[test]
    fn test_build() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let config = serde_json::json!({});
        let utils = Utils;

        let files = build(schema, config, &utils);
        assert!(!files.is_empty());
    }
}
