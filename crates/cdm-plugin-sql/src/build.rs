use cdm_plugin_interface::{OutputFile, Schema, Utils, JSON};
use crate::type_mapper::{Dialect, TypeMapper};
use crate::utils::generate_create_table;

/// Generates SQL DDL from the schema
pub fn build(schema: Schema, config: JSON, _utils: &Utils) -> Vec<OutputFile> {
    let mut files = Vec::new();
    let type_mapper = TypeMapper::new(&config, &schema.type_aliases);
    let dialect = type_mapper.dialect();

    // Generate schema file
    let mut sql = String::new();

    // Add header comment
    sql.push_str("-- Generated by CDM SQL Plugin\n");
    sql.push_str(&format!("-- Dialect: {:?}\n\n", dialect));

    // Iterate over models and generate CREATE TABLE statements
    for (model_name, model) in schema.models.iter() {
        // Check if model should be skipped
        if should_skip_model(&model.config) {
            continue;
        }

        let table_sql = generate_create_table(
            model_name,
            model,
            &config,
            &type_mapper,
        );
        sql.push_str(&table_sql);
        sql.push_str("\n");
    }

    // Determine output filename based on dialect
    let filename = match dialect {
        Dialect::PostgreSQL => "schema.postgres.sql",
        Dialect::SQLite => "schema.sqlite.sql",
    };

    files.push(OutputFile {
        path: filename.to_string(),
        content: sql,
    });

    files
}

fn should_skip_model(config: &JSON) -> bool {
    config
        .get("skip")
        .and_then(|v| v.as_bool())
        .unwrap_or(false)
}


#[cfg(test)]
#[path = "build/build_tests.rs"]
mod build_tests;
