use cdm_plugin_interface::{CaseFormat, FieldDefinition, ModelDefinition, OutputFile, Schema, Utils, JSON};
use crate::type_mapper::{Dialect, TypeMapper};

/// Generates SQL DDL from the schema
pub fn build(schema: Schema, config: JSON, _utils: &Utils) -> Vec<OutputFile> {
    let mut files = Vec::new();
    let type_mapper = TypeMapper::new(&config);
    let dialect = type_mapper.dialect();

    // Generate schema file
    let mut sql = String::new();

    // Add header comment
    sql.push_str("-- Generated by CDM SQL Plugin\n");
    sql.push_str(&format!("-- Dialect: {:?}\n\n", dialect));

    // Iterate over models and generate CREATE TABLE statements
    for (model_name, model) in schema.models.iter() {
        // Check if model should be skipped
        if should_skip_model(&model.config) {
            continue;
        }

        let table_sql = generate_create_table(
            model_name,
            model,
            &config,
            &type_mapper,
        );
        sql.push_str(&table_sql);
        sql.push_str("\n");
    }

    // Determine output filename based on dialect
    let filename = match dialect {
        Dialect::PostgreSQL => "schema.postgres.sql",
        Dialect::SQLite => "schema.sqlite.sql",
    };

    files.push(OutputFile {
        path: filename.to_string(),
        content: sql,
    });

    files
}

fn should_skip_model(config: &JSON) -> bool {
    config
        .get("skip")
        .and_then(|v| v.as_bool())
        .unwrap_or(false)
}

fn generate_create_table(
    model_name: &str,
    model: &ModelDefinition,
    global_config: &JSON,
    type_mapper: &TypeMapper,
) -> String {
    let mut sql = String::new();

    // Get table name (with optional override)
    let table_name = get_table_name(model_name, &model.config, global_config);

    // Get schema prefix (PostgreSQL only)
    let schema_prefix = get_schema_prefix(&model.config, global_config, type_mapper.dialect());

    // Start CREATE TABLE
    sql.push_str(&format!("CREATE TABLE {}{} (\n", schema_prefix, quote_identifier(&table_name, type_mapper.dialect())));

    // Generate column definitions
    let mut column_defs = Vec::new();
    for field in &model.fields {
        if should_skip_field(&field.config) {
            continue;
        }

        let column_def = generate_column_definition(field, global_config, type_mapper);
        column_defs.push(column_def);
    }

    // Add columns
    for (i, col) in column_defs.iter().enumerate() {
        sql.push_str("  ");
        sql.push_str(col);
        if i < column_defs.len() - 1 || has_constraints_or_indexes(&model.config) {
            sql.push(',');
        }
        sql.push('\n');
    }

    // Add constraints and indexes from model config
    let constraints_and_indexes = generate_constraints_and_indexes(&model.config, type_mapper.dialect());
    if !constraints_and_indexes.is_empty() {
        sql.push_str(&constraints_and_indexes);
    }

    sql.push_str(");\n");

    // Add standalone indexes (non-primary, non-unique via constraint)
    let indexes_sql = generate_standalone_indexes(&table_name, &schema_prefix, &model.config, type_mapper.dialect());
    if !indexes_sql.is_empty() {
        sql.push('\n');
        sql.push_str(&indexes_sql);
    }

    sql
}

fn should_skip_field(config: &JSON) -> bool {
    config
        .get("skip")
        .and_then(|v| v.as_bool())
        .unwrap_or(false)
}

fn get_table_name(model_name: &str, model_config: &JSON, global_config: &JSON) -> String {
    // Check for table_name override
    if let Some(override_name) = model_config.get("table_name").and_then(|v| v.as_str()) {
        return override_name.to_string();
    }

    // Apply table_name_format
    let format = global_config
        .get("table_name_format")
        .and_then(|v| v.as_str())
        .unwrap_or("snake_case");

    apply_name_format(model_name, format)
}

fn get_schema_prefix(model_config: &JSON, global_config: &JSON, dialect: Dialect) -> String {
    if dialect == Dialect::SQLite {
        return String::new();
    }

    // Check model-level schema override
    if let Some(schema) = model_config.get("schema").and_then(|v| v.as_str()) {
        return format!("{}.", quote_identifier(schema, dialect));
    }

    // Check global schema
    if let Some(schema) = global_config.get("schema").and_then(|v| v.as_str()) {
        return format!("{}.", quote_identifier(schema, dialect));
    }

    String::new()
}

fn generate_column_definition(
    field: &FieldDefinition,
    global_config: &JSON,
    type_mapper: &TypeMapper,
) -> String {
    let mut def = String::new();

    // Get column name
    let column_name = get_column_name(&field.name, &field.config, global_config);
    def.push_str(&quote_identifier(&column_name, type_mapper.dialect()));
    def.push(' ');

    // Get SQL type (check for override first)
    let sql_type = if let Some(type_override) = field.config.get("type").and_then(|v| v.as_str()) {
        type_override.to_string()
    } else {
        type_mapper.map_type(&field.field_type, field.optional)
    };
    def.push_str(&sql_type);

    // Add NOT NULL if field is required
    if !field.optional && should_infer_not_null(global_config) {
        def.push_str(" NOT NULL");
    }

    // Add DEFAULT if field has default value
    if let Some(default) = &field.default {
        if should_apply_cdm_defaults(global_config) {
            def.push_str(&format!(" DEFAULT {}", format_default_value(default)));
        }
    }

    def
}

fn get_column_name(field_name: &str, field_config: &JSON, global_config: &JSON) -> String {
    // Check for column_name override
    if let Some(override_name) = field_config.get("column_name").and_then(|v| v.as_str()) {
        return override_name.to_string();
    }

    // Apply column_name_format
    let format = global_config
        .get("column_name_format")
        .and_then(|v| v.as_str())
        .unwrap_or("snake_case");

    apply_name_format(field_name, format)
}

fn should_infer_not_null(global_config: &JSON) -> bool {
    global_config
        .get("infer_not_null")
        .and_then(|v| v.as_bool())
        .unwrap_or(true)
}

fn should_apply_cdm_defaults(global_config: &JSON) -> bool {
    global_config
        .get("apply_cdm_defaults")
        .and_then(|v| v.as_bool())
        .unwrap_or(true)
}

fn format_default_value(value: &cdm_plugin_interface::Value) -> String {
    match value {
        cdm_plugin_interface::Value::String(s) => format!("'{}'", s.replace('\'', "''")),
        cdm_plugin_interface::Value::Number(n) => n.to_string(),
        cdm_plugin_interface::Value::Boolean(b) => {
            if *b { "TRUE" } else { "FALSE" }.to_string()
        }
        cdm_plugin_interface::Value::Null => "NULL".to_string(),
    }
}

fn has_constraints_or_indexes(config: &JSON) -> bool {
    config.get("indexes").is_some() || config.get("constraints").is_some()
}

fn generate_constraints_and_indexes(config: &JSON, dialect: Dialect) -> String {
    let mut sql = String::new();

    // Generate primary key and unique constraints from indexes
    if let Some(indexes) = config.get("indexes").and_then(|v| v.as_array()) {
        for index in indexes {
            if let Some(true) = index.get("primary").and_then(|v| v.as_bool()) {
                // Primary key
                if let Some(fields) = index.get("fields").and_then(|v| v.as_array()) {
                    let field_names: Vec<String> = fields
                        .iter()
                        .filter_map(|f| f.as_str())
                        .map(|f| quote_identifier(f, dialect))
                        .collect();

                    sql.push_str("  PRIMARY KEY (");
                    sql.push_str(&field_names.join(", "));
                    sql.push_str("),\n");
                }
            } else if let Some(true) = index.get("unique").and_then(|v| v.as_bool()) {
                // Unique constraint
                if let Some(fields) = index.get("fields").and_then(|v| v.as_array()) {
                    let field_names: Vec<String> = fields
                        .iter()
                        .filter_map(|f| f.as_str())
                        .map(|f| quote_identifier(f, dialect))
                        .collect();

                    sql.push_str("  UNIQUE (");
                    sql.push_str(&field_names.join(", "));
                    sql.push_str("),\n");
                }
            }
        }
    }

    // Remove trailing comma and newline if present
    if sql.ends_with(",\n") {
        sql.truncate(sql.len() - 2);
        sql.push('\n');
    }

    sql
}

fn generate_standalone_indexes(
    table_name: &str,
    schema_prefix: &str,
    config: &JSON,
    dialect: Dialect,
) -> String {
    let mut sql = String::new();

    if let Some(indexes) = config.get("indexes").and_then(|v| v.as_array()) {
        for (i, index) in indexes.iter().enumerate() {
            // Skip primary keys and unique constraints (already handled)
            if index.get("primary").and_then(|v| v.as_bool()).unwrap_or(false) {
                continue;
            }
            if index.get("unique").and_then(|v| v.as_bool()).unwrap_or(false) {
                continue;
            }

            if let Some(fields) = index.get("fields").and_then(|v| v.as_array()) {
                let field_names: Vec<String> = fields
                    .iter()
                    .filter_map(|f| f.as_str())
                    .map(|f| quote_identifier(f, dialect))
                    .collect();

                // Generate index name
                let index_name = if let Some(name) = index.get("name").and_then(|v| v.as_str()) {
                    name.to_string()
                } else {
                    format!("idx_{}_{}", table_name, i)
                };

                sql.push_str(&format!("CREATE INDEX {} ON {}{} (",
                    quote_identifier(&index_name, dialect),
                    schema_prefix,
                    quote_identifier(table_name, dialect)
                ));
                sql.push_str(&field_names.join(", "));
                sql.push(')');

                // Add index method (PostgreSQL only)
                if dialect == Dialect::PostgreSQL {
                    if let Some(method) = index.get("method").and_then(|v| v.as_str()) {
                        sql.push_str(&format!(" USING {}", method.to_uppercase()));
                    }
                }

                // Add WHERE clause (PostgreSQL only)
                if dialect == Dialect::PostgreSQL {
                    if let Some(where_clause) = index.get("where").and_then(|v| v.as_str()) {
                        sql.push_str(&format!(" WHERE {}", where_clause));
                    }
                }

                sql.push_str(";\n");
            }
        }
    }

    sql
}

fn quote_identifier(name: &str, dialect: Dialect) -> String {
    match dialect {
        Dialect::PostgreSQL => format!("\"{}\"", name),
        Dialect::SQLite => format!("\"{}\"", name),
    }
}

fn apply_name_format(name: &str, format: &str) -> String {
    let case_format = match format {
        "snake_case" => CaseFormat::Snake,
        "camel_case" => CaseFormat::Camel,
        "pascal_case" => CaseFormat::Pascal,
        "preserve" => return name.to_string(),
        _ => CaseFormat::Snake,
    };

    let utils = Utils;
    utils.change_case(name, case_format)
}

#[cfg(test)]
mod tests {
    use super::*;
    use cdm_plugin_interface::{FieldDefinition, TypeExpression, Value};
    use serde_json::json;
    use std::collections::HashMap;

    #[test]
    fn test_build_empty_schema() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let config = json!({ "dialect": "postgresql" });
        let utils = Utils;

        let files = build(schema, config, &utils);
        assert_eq!(files.len(), 1);
        assert_eq!(files[0].path, "schema.postgres.sql");
        assert!(files[0].content.contains("-- Generated by CDM SQL Plugin"));
    }

    #[test]
    fn test_build_simple_model_postgresql() {
        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: String::new(),
                parents: vec![],
                entity_id: None,
                fields: vec![
                    FieldDefinition {
                        name: "id".to_string(),
                        field_type: TypeExpression::Identifier {
                            name: "number".to_string(),
                        },
                        optional: false,
                        default: None,
                        entity_id: None,
                        config: json!({}),
                    },
                    FieldDefinition {
                        name: "name".to_string(),
                        field_type: TypeExpression::Identifier {
                            name: "string".to_string(),
                        },
                        optional: false,
                        default: None,
                        entity_id: None,
                        config: json!({}),
                    },
                    FieldDefinition {
                        name: "email".to_string(),
                        field_type: TypeExpression::Identifier {
                            name: "string".to_string(),
                        },
                        optional: true,
                        default: None,
                        entity_id: None,
                        config: json!({}),
                    },
                ],
                config: json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let config = json!({ "dialect": "postgresql" });
        let utils = Utils;

        let files = build(schema, config, &utils);
        assert_eq!(files.len(), 1);

        let sql = &files[0].content;
        assert!(sql.contains("CREATE TABLE \"user\""));
        assert!(sql.contains("\"id\" DOUBLE PRECISION NOT NULL"));
        assert!(sql.contains("\"name\" VARCHAR(255) NOT NULL"));
        assert!(sql.contains("\"email\" VARCHAR(255)"));
        assert!(!sql.contains("\"email\" VARCHAR(255) NOT NULL")); // Optional field
    }

    #[test]
    fn test_build_simple_model_sqlite() {
        let mut models = HashMap::new();
        models.insert(
            "Product".to_string(),
            ModelDefinition {
                name: String::new(),
                parents: vec![],
                entity_id: None,
                fields: vec![
                    FieldDefinition {
                        name: "id".to_string(),
                        field_type: TypeExpression::Identifier {
                            name: "number".to_string(),
                        },
                        optional: false,
                        default: None,
                        entity_id: None,
                        config: json!({}),
                    },
                    FieldDefinition {
                        name: "active".to_string(),
                        field_type: TypeExpression::Identifier {
                            name: "boolean".to_string(),
                        },
                        optional: false,
                        default: Some(Value::Boolean(true)),
                        entity_id: None,
                        config: json!({}),
                    },
                ],
                config: json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let config = json!({ "dialect": "sqlite" });
        let utils = Utils;

        let files = build(schema, config, &utils);
        assert_eq!(files.len(), 1);
        assert_eq!(files[0].path, "schema.sqlite.sql");

        let sql = &files[0].content;
        assert!(sql.contains("CREATE TABLE \"product\""));
        assert!(sql.contains("\"id\" REAL NOT NULL"));
        assert!(sql.contains("\"active\" INTEGER NOT NULL DEFAULT TRUE"));
    }

    #[test]
    fn test_build_with_primary_key() {
        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: String::new(),
                parents: vec![],
                fields: vec![FieldDefinition {
                    name: "id".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "number".to_string(),
                    },
                    optional: false,
                    default: None,
                        entity_id: None,
                    config: json!({}),
                }],
                entity_id: None,
                config: json!({
                    "indexes": [
                        {
                            "fields": ["id"],
                            "primary": true
                        }
                    ]
                }),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let config = json!({ "dialect": "postgresql" });
        let utils = Utils;

        let files = build(schema, config, &utils);
        let sql = &files[0].content;

        assert!(sql.contains("PRIMARY KEY (\"id\")"));
    }

    #[test]
    fn test_build_with_unique_constraint() {
        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: String::new(),
                parents: vec![],
                fields: vec![
                    FieldDefinition {
                        name: "id".to_string(),
                        field_type: TypeExpression::Identifier {
                            name: "number".to_string(),
                        },
                        optional: false,
                        default: None,
                        entity_id: None,
                        config: json!({}),
                    },
                    FieldDefinition {
                        name: "email".to_string(),
                        field_type: TypeExpression::Identifier {
                            name: "string".to_string(),
                        },
                        optional: false,
                        default: None,
                        entity_id: None,
                        config: json!({}),
                    },
                ],
                entity_id: None,
                config: json!({
                    "indexes": [
                        {
                            "fields": ["email"],
                            "unique": true
                        }
                    ]
                }),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let config = json!({ "dialect": "postgresql" });
        let utils = Utils;

        let files = build(schema, config, &utils);
        let sql = &files[0].content;

        assert!(sql.contains("UNIQUE (\"email\")"));
    }

    #[test]
    fn test_build_with_regular_index() {
        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: String::new(),
                parents: vec![],
                fields: vec![
                    FieldDefinition {
                        name: "name".to_string(),
                        field_type: TypeExpression::Identifier {
                            name: "string".to_string(),
                        },
                        optional: false,
                        default: None,
                        entity_id: None,
                        config: json!({}),
                    },
                ],
                entity_id: None,
                config: json!({
                    "indexes": [
                        {
                            "fields": ["name"]
                        }
                    ]
                }),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let config = json!({ "dialect": "postgresql" });
        let utils = Utils;

        let files = build(schema, config, &utils);
        let sql = &files[0].content;

        assert!(sql.contains("CREATE INDEX"));
        assert!(sql.contains("ON \"user\" (\"name\")"));
    }

    #[test]
    fn test_build_with_type_override() {
        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: String::new(),
                parents: vec![],
                fields: vec![FieldDefinition {
                    name: "data".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: None,
                        entity_id: None,
                    config: json!({
                        "type": "TEXT"
                    }),
                }],
                entity_id: None,
                config: json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let config = json!({ "dialect": "postgresql" });
        let utils = Utils;

        let files = build(schema, config, &utils);
        let sql = &files[0].content;

        assert!(sql.contains("\"data\" TEXT NOT NULL"));
    }

    #[test]
    fn test_build_skip_model() {
        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: String::new(),
                parents: vec![],
                entity_id: None,
                fields: vec![],
                config: json!({ "skip": true }),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let config = json!({ "dialect": "postgresql" });
        let utils = Utils;

        let files = build(schema, config, &utils);
        let sql = &files[0].content;

        assert!(!sql.contains("CREATE TABLE"));
    }

    #[test]
    fn test_apply_name_format() {
        assert_eq!(apply_name_format("UserProfile", "snake_case"), "user_profile");
        assert_eq!(apply_name_format("UserProfile", "preserve"), "UserProfile");
        assert_eq!(apply_name_format("user_profile", "pascal_case"), "UserProfile");
        assert_eq!(apply_name_format("user_profile", "camel_case"), "userProfile");
    }
}
