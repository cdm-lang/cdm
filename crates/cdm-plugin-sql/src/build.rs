use cdm_plugin_interface::{OutputFile, Schema, Utils, JSON};
use crate::type_mapper::{Dialect, TypeMapper};
use crate::utils::generate_create_table;

/// Generates SQL DDL from the schema
pub fn build(schema: Schema, config: JSON, _utils: &Utils) -> Vec<OutputFile> {
    let mut files = Vec::new();
    let type_mapper = TypeMapper::new(&config);
    let dialect = type_mapper.dialect();

    // Generate schema file
    let mut sql = String::new();

    // Add header comment
    sql.push_str("-- Generated by CDM SQL Plugin\n");
    sql.push_str(&format!("-- Dialect: {:?}\n\n", dialect));

    // Iterate over models and generate CREATE TABLE statements
    for (model_name, model) in schema.models.iter() {
        // Check if model should be skipped
        if should_skip_model(&model.config) {
            continue;
        }

        let table_sql = generate_create_table(
            model_name,
            model,
            &config,
            &type_mapper,
        );
        sql.push_str(&table_sql);
        sql.push_str("\n");
    }

    // Determine output filename based on dialect
    let filename = match dialect {
        Dialect::PostgreSQL => "schema.postgres.sql",
        Dialect::SQLite => "schema.sqlite.sql",
    };

    files.push(OutputFile {
        path: filename.to_string(),
        content: sql,
    });

    files
}

fn should_skip_model(config: &JSON) -> bool {
    config
        .get("skip")
        .and_then(|v| v.as_bool())
        .unwrap_or(false)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::utils::apply_name_format;
    use cdm_plugin_interface::{FieldDefinition, ModelDefinition, TypeExpression, Value};
    use serde_json::json;
    use std::collections::HashMap;

    #[test]
    fn test_build_empty_schema() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let config = json!({ "dialect": "postgresql" });
        let utils = Utils;

        let files = build(schema, config, &utils);
        assert_eq!(files.len(), 1);
        assert_eq!(files[0].path, "schema.postgres.sql");
        assert!(files[0].content.contains("-- Generated by CDM SQL Plugin"));
    }

    #[test]
    fn test_build_simple_model_postgresql() {
        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: String::new(),
                parents: vec![],
                entity_id: None,
                fields: vec![
                    FieldDefinition {
                        name: "id".to_string(),
                        field_type: TypeExpression::Identifier {
                            name: "number".to_string(),
                        },
                        optional: false,
                        default: None,
                        entity_id: None,
                        config: json!({}),
                    },
                    FieldDefinition {
                        name: "name".to_string(),
                        field_type: TypeExpression::Identifier {
                            name: "string".to_string(),
                        },
                        optional: false,
                        default: None,
                        entity_id: None,
                        config: json!({}),
                    },
                    FieldDefinition {
                        name: "email".to_string(),
                        field_type: TypeExpression::Identifier {
                            name: "string".to_string(),
                        },
                        optional: true,
                        default: None,
                        entity_id: None,
                        config: json!({}),
                    },
                ],
                config: json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let config = json!({ "dialect": "postgresql" });
        let utils = Utils;

        let files = build(schema, config, &utils);
        assert_eq!(files.len(), 1);

        let sql = &files[0].content;
        assert!(sql.contains("CREATE TABLE \"user\""));
        assert!(sql.contains("\"id\" DOUBLE PRECISION NOT NULL"));
        assert!(sql.contains("\"name\" VARCHAR(255) NOT NULL"));
        assert!(sql.contains("\"email\" VARCHAR(255)"));
        assert!(!sql.contains("\"email\" VARCHAR(255) NOT NULL")); // Optional field
    }

    #[test]
    fn test_build_simple_model_sqlite() {
        let mut models = HashMap::new();
        models.insert(
            "Product".to_string(),
            ModelDefinition {
                name: String::new(),
                parents: vec![],
                entity_id: None,
                fields: vec![
                    FieldDefinition {
                        name: "id".to_string(),
                        field_type: TypeExpression::Identifier {
                            name: "number".to_string(),
                        },
                        optional: false,
                        default: None,
                        entity_id: None,
                        config: json!({}),
                    },
                    FieldDefinition {
                        name: "active".to_string(),
                        field_type: TypeExpression::Identifier {
                            name: "boolean".to_string(),
                        },
                        optional: false,
                        default: Some(Value::Boolean(true)),
                        entity_id: None,
                        config: json!({}),
                    },
                ],
                config: json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let config = json!({ "dialect": "sqlite" });
        let utils = Utils;

        let files = build(schema, config, &utils);
        assert_eq!(files.len(), 1);
        assert_eq!(files[0].path, "schema.sqlite.sql");

        let sql = &files[0].content;
        assert!(sql.contains("CREATE TABLE \"product\""));
        assert!(sql.contains("\"id\" REAL NOT NULL"));
        assert!(sql.contains("\"active\" INTEGER NOT NULL DEFAULT TRUE"));
    }

    #[test]
    fn test_build_with_primary_key() {
        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: String::new(),
                parents: vec![],
                fields: vec![FieldDefinition {
                    name: "id".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "number".to_string(),
                    },
                    optional: false,
                    default: None,
                        entity_id: None,
                    config: json!({}),
                }],
                entity_id: None,
                config: json!({
                    "indexes": [
                        {
                            "fields": ["id"],
                            "primary": true
                        }
                    ]
                }),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let config = json!({ "dialect": "postgresql" });
        let utils = Utils;

        let files = build(schema, config, &utils);
        let sql = &files[0].content;

        assert!(sql.contains("PRIMARY KEY (\"id\")"));
    }

    #[test]
    fn test_build_with_unique_constraint() {
        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: String::new(),
                parents: vec![],
                fields: vec![
                    FieldDefinition {
                        name: "id".to_string(),
                        field_type: TypeExpression::Identifier {
                            name: "number".to_string(),
                        },
                        optional: false,
                        default: None,
                        entity_id: None,
                        config: json!({}),
                    },
                    FieldDefinition {
                        name: "email".to_string(),
                        field_type: TypeExpression::Identifier {
                            name: "string".to_string(),
                        },
                        optional: false,
                        default: None,
                        entity_id: None,
                        config: json!({}),
                    },
                ],
                entity_id: None,
                config: json!({
                    "indexes": [
                        {
                            "fields": ["email"],
                            "unique": true
                        }
                    ]
                }),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let config = json!({ "dialect": "postgresql" });
        let utils = Utils;

        let files = build(schema, config, &utils);
        let sql = &files[0].content;

        assert!(sql.contains("UNIQUE (\"email\")"));
    }

    #[test]
    fn test_build_with_regular_index() {
        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: String::new(),
                parents: vec![],
                fields: vec![
                    FieldDefinition {
                        name: "name".to_string(),
                        field_type: TypeExpression::Identifier {
                            name: "string".to_string(),
                        },
                        optional: false,
                        default: None,
                        entity_id: None,
                        config: json!({}),
                    },
                ],
                entity_id: None,
                config: json!({
                    "indexes": [
                        {
                            "fields": ["name"]
                        }
                    ]
                }),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let config = json!({ "dialect": "postgresql" });
        let utils = Utils;

        let files = build(schema, config, &utils);
        let sql = &files[0].content;

        assert!(sql.contains("CREATE INDEX"));
        assert!(sql.contains("ON \"user\" (\"name\")"));
    }

    #[test]
    fn test_build_with_type_override() {
        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: String::new(),
                parents: vec![],
                fields: vec![FieldDefinition {
                    name: "data".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: None,
                        entity_id: None,
                    config: json!({
                        "type": "TEXT"
                    }),
                }],
                entity_id: None,
                config: json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let config = json!({ "dialect": "postgresql" });
        let utils = Utils;

        let files = build(schema, config, &utils);
        let sql = &files[0].content;

        assert!(sql.contains("\"data\" TEXT NOT NULL"));
    }

    #[test]
    fn test_build_skip_model() {
        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: String::new(),
                parents: vec![],
                entity_id: None,
                fields: vec![],
                config: json!({ "skip": true }),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let config = json!({ "dialect": "postgresql" });
        let utils = Utils;

        let files = build(schema, config, &utils);
        let sql = &files[0].content;

        assert!(!sql.contains("CREATE TABLE"));
    }

    #[test]
    fn test_apply_name_format() {
        assert_eq!(apply_name_format("UserProfile", "snake_case"), "user_profile");
        assert_eq!(apply_name_format("UserProfile", "preserve"), "UserProfile");
        assert_eq!(apply_name_format("user_profile", "pascal_case"), "UserProfile");
        assert_eq!(apply_name_format("user_profile", "camel_case"), "userProfile");
    }
}
