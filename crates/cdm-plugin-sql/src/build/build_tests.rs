use super::*;
use crate::utils::apply_name_format;
use cdm_plugin_interface::{FieldDefinition, ModelDefinition, TypeExpression};
use serde_json::json;
use std::collections::HashMap;
use std::path::PathBuf;

fn fixtures_path() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("test_fixtures")
}

fn load_test_schema(fixture_name: &str) -> Schema {
    let path = fixtures_path().join(fixture_name);
    let content = std::fs::read_to_string(&path)
        .unwrap_or_else(|e| panic!("Failed to load fixture {}: {}", path.display(), e));
    serde_json::from_str(&content)
        .unwrap_or_else(|e| panic!("Failed to parse fixture {}: {}", path.display(), e))
}

#[test]
fn test_build_empty_schema() {
    let schema = Schema {
        type_aliases: HashMap::new(),
        models: HashMap::new(),
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    assert_eq!(files.len(), 1);
    assert_eq!(files[0].path, "schema.postgres.sql");
    assert!(files[0].content.contains("-- Generated by CDM SQL Plugin"));
}

#[test]
fn test_build_simple_model_postgresql() {
    let schema = load_test_schema("user_schema.json");

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    assert_eq!(files.len(), 1);

    let sql = &files[0].content;
    assert!(sql.contains("CREATE TABLE \"user\""));
    assert!(sql.contains("\"id\" DOUBLE PRECISION NOT NULL"));
    assert!(sql.contains("\"name\" VARCHAR(255) NOT NULL"));
    assert!(sql.contains("\"email\" VARCHAR(255)"));
    assert!(!sql.contains("\"email\" VARCHAR(255) NOT NULL")); // Optional field
}

#[test]
fn test_build_simple_model_sqlite() {
    let schema = load_test_schema("product_schema.json");

    let config = json!({
        "dialect": "sqlite",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    assert_eq!(files.len(), 1);
    assert_eq!(files[0].path, "schema.sqlite.sql");

    let sql = &files[0].content;
    assert!(sql.contains("CREATE TABLE \"product\""));
    assert!(sql.contains("\"id\" REAL NOT NULL"));
    assert!(sql.contains("\"active\" INTEGER NOT NULL DEFAULT TRUE"));
}

#[test]
fn test_build_with_primary_key() {
    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![FieldDefinition {
                name: "id".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "number".to_string(),
                },
                optional: false,
                default: None,
                entity_id: None,
                config: json!({}),
            }],
            entity_id: None,
            config: json!({
                "indexes": [
                    {
                        "fields": ["id"],
                        "primary": true
                    }
                ]
            }),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    assert!(sql.contains("PRIMARY KEY (\"id\")"));
}

#[test]
fn test_build_with_unique_constraint() {
    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![
                FieldDefinition {
                    name: "id".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "number".to_string(),
                    },
                    optional: false,
                    default: None,
                    entity_id: None,
                    config: json!({}),
                },
                FieldDefinition {
                    name: "email".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: None,
                    entity_id: None,
                    config: json!({}),
                },
            ],
            entity_id: None,
            config: json!({
                "indexes": [
                    {
                        "fields": ["email"],
                        "unique": true
                    }
                ]
            }),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    assert!(sql.contains("UNIQUE (\"email\")"));
}

#[test]
fn test_build_with_regular_index() {
    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![FieldDefinition {
                name: "name".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "string".to_string(),
                },
                optional: false,
                default: None,
                entity_id: None,
                config: json!({}),
            }],
            entity_id: None,
            config: json!({
                "indexes": [
                    {
                        "fields": ["name"]
                    }
                ]
            }),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    assert!(sql.contains("CREATE INDEX"));
    assert!(sql.contains("ON \"user\" (\"name\")"));
}

#[test]
fn test_build_with_type_override() {
    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![FieldDefinition {
                name: "data".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "string".to_string(),
                },
                optional: false,
                default: None,
                entity_id: None,
                config: json!({
                    "type": "TEXT"
                }),
            }],
            entity_id: None,
            config: json!({}),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    assert!(sql.contains("\"data\" TEXT NOT NULL"));
}

#[test]
fn test_build_skip_model() {
    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            entity_id: None,
            fields: vec![],
            config: json!({ "skip": true }),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    assert!(!sql.contains("CREATE TABLE"));
}

#[test]
fn test_apply_name_format() {
    assert_eq!(
        apply_name_format("UserProfile", "snake_case"),
        "user_profile"
    );
    assert_eq!(apply_name_format("UserProfile", "preserve"), "UserProfile");
    assert_eq!(
        apply_name_format("user_profile", "pascal_case"),
        "UserProfile"
    );
    assert_eq!(
        apply_name_format("user_profile", "camel_case"),
        "userProfile"
    );
}

#[test]
fn test_build_with_type_alias_sql_type_override() {
    // This test verifies that a type alias with @sql { type: "INTEGER" } annotation
    // is correctly used when a field references that type alias.
    // Bug: numeric type aliases with explicit SQL type were incorrectly built as JSONB.

    use cdm_plugin_interface::TypeAliasDefinition;

    let mut type_aliases = HashMap::new();
    type_aliases.insert(
        "ID".to_string(),
        TypeAliasDefinition {
            name: "ID".to_string(),
            alias_type: TypeExpression::Identifier {
                name: "number".to_string(),
            },
            config: json!({
                "type": "INTEGER"
            }),
            entity_id: None,
        },
    );

    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![FieldDefinition {
                name: "id".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "ID".to_string(),
                },
                optional: false,
                default: None,
                entity_id: None,
                config: json!({}),
            }],
            entity_id: None,
            config: json!({}),
        },
    );

    let schema = Schema {
        type_aliases,
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    // The field should use INTEGER (from type alias config), not JSONB
    assert!(
        sql.contains("\"id\" INTEGER NOT NULL"),
        "Expected 'id' column to be INTEGER, but got:\n{}",
        sql
    );
    assert!(
        !sql.contains("JSONB"),
        "Should not contain JSONB, but got:\n{}",
        sql
    );
}
