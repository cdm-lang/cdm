use super::*;
use crate::utils::apply_name_format;
use cdm_plugin_interface::{FieldDefinition, ModelDefinition, TypeExpression, Value};
use serde_json::json;
use std::collections::HashMap;

#[test]
fn test_build_empty_schema() {
    let schema = Schema {
        type_aliases: HashMap::new(),
        models: HashMap::new(),
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    assert_eq!(files.len(), 1);
    assert_eq!(files[0].path, "schema.postgres.sql");
    assert!(files[0].content.contains("-- Generated by CDM SQL Plugin"));
}

#[test]
fn test_build_simple_model_postgresql() {
    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            entity_id: None,
            fields: vec![
                FieldDefinition {
                    name: "id".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "number".to_string(),
                    },
                    optional: false,
                    default: None,
                    entity_id: None,
                    config: json!({}),
                },
                FieldDefinition {
                    name: "name".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: None,
                    entity_id: None,
                    config: json!({}),
                },
                FieldDefinition {
                    name: "email".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: true,
                    default: None,
                    entity_id: None,
                    config: json!({}),
                },
            ],
            config: json!({}),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    assert_eq!(files.len(), 1);

    let sql = &files[0].content;
    assert!(sql.contains("CREATE TABLE \"user\""));
    assert!(sql.contains("\"id\" DOUBLE PRECISION NOT NULL"));
    assert!(sql.contains("\"name\" VARCHAR(255) NOT NULL"));
    assert!(sql.contains("\"email\" VARCHAR(255)"));
    assert!(!sql.contains("\"email\" VARCHAR(255) NOT NULL")); // Optional field
}

#[test]
fn test_build_simple_model_sqlite() {
    let mut models = HashMap::new();
    models.insert(
        "Product".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            entity_id: None,
            fields: vec![
                FieldDefinition {
                    name: "id".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "number".to_string(),
                    },
                    optional: false,
                    default: None,
                    entity_id: None,
                    config: json!({}),
                },
                FieldDefinition {
                    name: "active".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "boolean".to_string(),
                    },
                    optional: false,
                    default: Some(Value::Boolean(true)),
                    entity_id: None,
                    config: json!({}),
                },
            ],
            config: json!({}),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "sqlite",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    assert_eq!(files.len(), 1);
    assert_eq!(files[0].path, "schema.sqlite.sql");

    let sql = &files[0].content;
    assert!(sql.contains("CREATE TABLE \"product\""));
    assert!(sql.contains("\"id\" REAL NOT NULL"));
    assert!(sql.contains("\"active\" INTEGER NOT NULL DEFAULT TRUE"));
}

#[test]
fn test_build_with_primary_key() {
    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![FieldDefinition {
                name: "id".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "number".to_string(),
                },
                optional: false,
                default: None,
                entity_id: None,
                config: json!({}),
            }],
            entity_id: None,
            config: json!({
                "indexes": [
                    {
                        "fields": ["id"],
                        "primary": true
                    }
                ]
            }),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    assert!(sql.contains("PRIMARY KEY (\"id\")"));
}

#[test]
fn test_build_with_unique_constraint() {
    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![
                FieldDefinition {
                    name: "id".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "number".to_string(),
                    },
                    optional: false,
                    default: None,
                    entity_id: None,
                    config: json!({}),
                },
                FieldDefinition {
                    name: "email".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: None,
                    entity_id: None,
                    config: json!({}),
                },
            ],
            entity_id: None,
            config: json!({
                "indexes": [
                    {
                        "fields": ["email"],
                        "unique": true
                    }
                ]
            }),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    assert!(sql.contains("UNIQUE (\"email\")"));
}

#[test]
fn test_build_with_regular_index() {
    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![FieldDefinition {
                name: "name".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "string".to_string(),
                },
                optional: false,
                default: None,
                entity_id: None,
                config: json!({}),
            }],
            entity_id: None,
            config: json!({
                "indexes": [
                    {
                        "fields": ["name"]
                    }
                ]
            }),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    assert!(sql.contains("CREATE INDEX"));
    assert!(sql.contains("ON \"user\" (\"name\")"));
}

#[test]
fn test_build_with_type_override() {
    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![FieldDefinition {
                name: "data".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "string".to_string(),
                },
                optional: false,
                default: None,
                entity_id: None,
                config: json!({
                    "type": "TEXT"
                }),
            }],
            entity_id: None,
            config: json!({}),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    assert!(sql.contains("\"data\" TEXT NOT NULL"));
}

#[test]
fn test_build_skip_model() {
    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            entity_id: None,
            fields: vec![],
            config: json!({ "skip": true }),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    assert!(!sql.contains("CREATE TABLE"));
}

#[test]
fn test_apply_name_format() {
    assert_eq!(
        apply_name_format("UserProfile", "snake_case"),
        "user_profile"
    );
    assert_eq!(apply_name_format("UserProfile", "preserve"), "UserProfile");
    assert_eq!(
        apply_name_format("user_profile", "pascal_case"),
        "UserProfile"
    );
    assert_eq!(
        apply_name_format("user_profile", "camel_case"),
        "userProfile"
    );
}
