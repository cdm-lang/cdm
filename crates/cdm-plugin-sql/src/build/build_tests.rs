use super::*;
use crate::utils::apply_name_format;
use cdm_plugin_interface::{FieldDefinition, ModelDefinition, TypeExpression};
use serde_json::json;
use std::collections::HashMap;
use std::path::PathBuf;

fn fixtures_path() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("test_fixtures")
}

fn load_test_schema(fixture_name: &str) -> Schema {
    let path = fixtures_path().join(fixture_name);
    let content = std::fs::read_to_string(&path)
        .unwrap_or_else(|e| panic!("Failed to load fixture {}: {}", path.display(), e));
    serde_json::from_str(&content)
        .unwrap_or_else(|e| panic!("Failed to parse fixture {}: {}", path.display(), e))
}

#[test]
fn test_build_empty_schema() {
    let schema = Schema {
        type_aliases: HashMap::new(),
        models: HashMap::new(),
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    assert_eq!(files.len(), 1);
    assert_eq!(files[0].path, "schema.postgres.sql");
    assert!(files[0].content.contains("-- Generated by CDM SQL Plugin"));
}

#[test]
fn test_build_simple_model_postgresql() {
    let schema = load_test_schema("user_schema.json");

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    assert_eq!(files.len(), 1);

    let sql = &files[0].content;
    assert!(sql.contains("CREATE TABLE \"user\""));
    assert!(sql.contains("\"id\" DOUBLE PRECISION NOT NULL"));
    assert!(sql.contains("\"name\" VARCHAR(255) NOT NULL"));
    assert!(sql.contains("\"email\" VARCHAR(255)"));
    assert!(!sql.contains("\"email\" VARCHAR(255) NOT NULL")); // Optional field
}

#[test]
fn test_build_simple_model_sqlite() {
    let schema = load_test_schema("product_schema.json");

    let config = json!({
        "dialect": "sqlite",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    assert_eq!(files.len(), 1);
    assert_eq!(files[0].path, "schema.sqlite.sql");

    let sql = &files[0].content;
    assert!(sql.contains("CREATE TABLE \"product\""));
    assert!(sql.contains("\"id\" REAL NOT NULL"));
    assert!(sql.contains("\"active\" INTEGER NOT NULL DEFAULT TRUE"));
}

#[test]
fn test_build_with_primary_key() {
    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![FieldDefinition {
                name: "id".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "number".to_string(),
                },
                optional: false,
                default: None,
                entity_id: None,
                config: json!({}),
            }],
            entity_id: None,
            config: json!({
                "indexes": [
                    {
                        "fields": ["id"],
                        "primary": true
                    }
                ]
            }),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    assert!(sql.contains("PRIMARY KEY (\"id\")"));
}

#[test]
fn test_build_with_unique_constraint() {
    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![
                FieldDefinition {
                    name: "id".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "number".to_string(),
                    },
                    optional: false,
                    default: None,
                    entity_id: None,
                    config: json!({}),
                },
                FieldDefinition {
                    name: "email".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: None,
                    entity_id: None,
                    config: json!({}),
                },
            ],
            entity_id: None,
            config: json!({
                "indexes": [
                    {
                        "fields": ["email"],
                        "unique": true
                    }
                ]
            }),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    assert!(sql.contains("UNIQUE (\"email\")"));
}

#[test]
fn test_build_with_regular_index() {
    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![FieldDefinition {
                name: "name".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "string".to_string(),
                },
                optional: false,
                default: None,
                entity_id: None,
                config: json!({}),
            }],
            entity_id: None,
            config: json!({
                "indexes": [
                    {
                        "fields": ["name"]
                    }
                ]
            }),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    assert!(sql.contains("CREATE INDEX"));
    assert!(sql.contains("ON \"user\" (\"name\")"));
}

#[test]
fn test_build_with_type_override() {
    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![FieldDefinition {
                name: "data".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "string".to_string(),
                },
                optional: false,
                default: None,
                entity_id: None,
                config: json!({
                    "type": "TEXT"
                }),
            }],
            entity_id: None,
            config: json!({}),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    assert!(sql.contains("\"data\" TEXT NOT NULL"));
}

#[test]
fn test_build_skip_model() {
    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            entity_id: None,
            fields: vec![],
            config: json!({ "skip": true }),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    assert!(!sql.contains("CREATE TABLE"));
}

#[test]
fn test_apply_name_format() {
    assert_eq!(
        apply_name_format("UserProfile", "snake_case"),
        "user_profile"
    );
    assert_eq!(apply_name_format("UserProfile", "preserve"), "UserProfile");
    assert_eq!(
        apply_name_format("user_profile", "pascal_case"),
        "UserProfile"
    );
    assert_eq!(
        apply_name_format("user_profile", "camel_case"),
        "userProfile"
    );
}

#[test]
fn test_build_with_type_alias_sql_type_override() {
    // This test verifies that a type alias with @sql { type: "INTEGER" } annotation
    // is correctly used when a field references that type alias.
    // Bug: numeric type aliases with explicit SQL type were incorrectly built as JSONB.

    use cdm_plugin_interface::TypeAliasDefinition;

    let mut type_aliases = HashMap::new();
    type_aliases.insert(
        "ID".to_string(),
        TypeAliasDefinition {
            name: "ID".to_string(),
            alias_type: TypeExpression::Identifier {
                name: "number".to_string(),
            },
            config: json!({
                "type": "INTEGER"
            }),
            entity_id: None,
        },
    );

    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![FieldDefinition {
                name: "id".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "ID".to_string(),
                },
                optional: false,
                default: None,
                entity_id: None,
                config: json!({}),
            }],
            entity_id: None,
            config: json!({}),
        },
    );

    let schema = Schema {
        type_aliases,
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    // The field should use INTEGER (from type alias config), not JSONB
    assert!(
        sql.contains("\"id\" INTEGER NOT NULL"),
        "Expected 'id' column to be INTEGER, but got:\n{}",
        sql
    );
    assert!(
        !sql.contains("JSONB"),
        "Should not contain JSONB, but got:\n{}",
        sql
    );
}

#[test]
fn test_build_with_field_config_default() {
    // Test that field-level config default (SQL expression) is applied
    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![FieldDefinition {
                name: "id".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "string".to_string(),
                },
                optional: false,
                default: None,
                entity_id: None,
                config: json!({
                    "type": "UUID",
                    "default": "gen_random_uuid()"
                }),
            }],
            entity_id: None,
            config: json!({}),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    assert!(
        sql.contains("\"id\" UUID NOT NULL DEFAULT gen_random_uuid()"),
        "Expected field config default to be applied, but got:\n{}",
        sql
    );
}

#[test]
fn test_build_with_type_alias_default() {
    // Test that type alias default (SQL expression) is applied when field has no default
    use cdm_plugin_interface::TypeAliasDefinition;

    let mut type_aliases = HashMap::new();
    type_aliases.insert(
        "UUID".to_string(),
        TypeAliasDefinition {
            name: "UUID".to_string(),
            alias_type: TypeExpression::Identifier {
                name: "string".to_string(),
            },
            config: json!({
                "type": "UUID",
                "default": "gen_random_uuid()"
            }),
            entity_id: None,
        },
    );

    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![FieldDefinition {
                name: "id".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "UUID".to_string(),
                },
                optional: false,
                default: None,
                entity_id: None,
                config: json!({}),
            }],
            entity_id: None,
            config: json!({}),
        },
    );

    let schema = Schema {
        type_aliases,
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    assert!(
        sql.contains("\"id\" UUID NOT NULL DEFAULT gen_random_uuid()"),
        "Expected type alias default to be applied, but got:\n{}",
        sql
    );
}

#[test]
fn test_build_field_config_default_takes_precedence_over_type_alias() {
    // Test that field-level config default takes precedence over type alias default
    use cdm_plugin_interface::TypeAliasDefinition;

    let mut type_aliases = HashMap::new();
    type_aliases.insert(
        "Timestamp".to_string(),
        TypeAliasDefinition {
            name: "Timestamp".to_string(),
            alias_type: TypeExpression::Identifier {
                name: "string".to_string(),
            },
            config: json!({
                "type": "TIMESTAMP",
                "default": "CURRENT_TIMESTAMP"
            }),
            entity_id: None,
        },
    );

    let mut models = HashMap::new();
    models.insert(
        "Event".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![FieldDefinition {
                name: "deleted_at".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "Timestamp".to_string(),
                },
                optional: true,
                default: None,
                entity_id: None,
                config: json!({
                    "default": "NULL"
                }),
            }],
            entity_id: None,
            config: json!({}),
        },
    );

    let schema = Schema {
        type_aliases,
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    // Should use field config default (NULL), not type alias default (CURRENT_TIMESTAMP)
    assert!(
        sql.contains("\"deleted_at\" TIMESTAMP DEFAULT NULL"),
        "Expected field config default to override type alias default, but got:\n{}",
        sql
    );
    assert!(
        !sql.contains("CURRENT_TIMESTAMP"),
        "Type alias default should NOT be used when field config has default, but got:\n{}",
        sql
    );
}

#[test]
fn test_build_field_config_default_takes_precedence_over_cdm_default() {
    // Test that field-level config default takes precedence over CDM schema default
    use cdm_plugin_interface::Value;

    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![FieldDefinition {
                name: "created_at".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "string".to_string(),
                },
                optional: false,
                default: Some(Value::String("2024-01-01".to_string())), // CDM default
                entity_id: None,
                config: json!({
                    "type": "TIMESTAMP",
                    "default": "NOW()"  // SQL expression override
                }),
            }],
            entity_id: None,
            config: json!({}),
        },
    );

    let schema = Schema {
        type_aliases: HashMap::new(),
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    // Should use field config default (NOW()), not CDM default ('2024-01-01')
    assert!(
        sql.contains("DEFAULT NOW()"),
        "Expected field config default to override CDM default, but got:\n{}",
        sql
    );
    assert!(
        !sql.contains("'2024-01-01'"),
        "CDM default should NOT be used when field config has default, but got:\n{}",
        sql
    );
}

#[test]
fn test_build_type_alias_default_takes_precedence_over_cdm_default() {
    // Test that type alias default takes precedence over CDM schema default
    use cdm_plugin_interface::{TypeAliasDefinition, Value};

    let mut type_aliases = HashMap::new();
    type_aliases.insert(
        "CreatedAt".to_string(),
        TypeAliasDefinition {
            name: "CreatedAt".to_string(),
            alias_type: TypeExpression::Identifier {
                name: "string".to_string(),
            },
            config: json!({
                "type": "TIMESTAMP",
                "default": "CURRENT_TIMESTAMP"
            }),
            entity_id: None,
        },
    );

    let mut models = HashMap::new();
    models.insert(
        "User".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![FieldDefinition {
                name: "created_at".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "CreatedAt".to_string(),
                },
                optional: false,
                default: Some(Value::String("2024-01-01".to_string())), // CDM default
                entity_id: None,
                config: json!({}),
            }],
            entity_id: None,
            config: json!({}),
        },
    );

    let schema = Schema {
        type_aliases,
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    // Should use type alias default (CURRENT_TIMESTAMP), not CDM default ('2024-01-01')
    assert!(
        sql.contains("DEFAULT CURRENT_TIMESTAMP"),
        "Expected type alias default to override CDM default, but got:\n{}",
        sql
    );
    assert!(
        !sql.contains("'2024-01-01'"),
        "CDM default should NOT be used when type alias has default, but got:\n{}",
        sql
    );
}

#[test]
fn test_build_with_qualified_template_type_alias() {
    // This test verifies that qualified template type names like "sql.UUID" are
    // correctly resolved to their SQL types.
    // Bug: Fields using qualified template types (e.g., sqlType.UUID) were getting
    // JSONB instead of the type defined in the template's @sql { type: "UUID" } config.

    use cdm_plugin_interface::TypeAliasDefinition;

    let mut type_aliases = HashMap::new();

    // Simulate template type aliases with qualified names as they would be stored
    // in the schema sent to the SQL plugin
    type_aliases.insert(
        "sql.UUID".to_string(),
        TypeAliasDefinition {
            name: "UUID".to_string(),
            alias_type: TypeExpression::Identifier {
                name: "string".to_string(),
            },
            config: json!({
                "type": "UUID"
            }),
            entity_id: None,
        },
    );

    type_aliases.insert(
        "sql.TimestampTZ".to_string(),
        TypeAliasDefinition {
            name: "TimestampTZ".to_string(),
            alias_type: TypeExpression::Identifier {
                name: "string".to_string(),
            },
            config: json!({
                "type": "TIMESTAMPTZ"
            }),
            entity_id: None,
        },
    );

    let mut models = HashMap::new();
    models.insert(
        "Entity".to_string(),
        ModelDefinition {
            name: String::new(),
            parents: vec![],
            fields: vec![
                FieldDefinition {
                    name: "id".to_string(),
                    // Field uses qualified type name
                    field_type: TypeExpression::Identifier {
                        name: "sql.UUID".to_string(),
                    },
                    optional: false,
                    default: None,
                    entity_id: None,
                    config: json!({}),
                },
                FieldDefinition {
                    name: "created_at".to_string(),
                    // Field uses qualified type name
                    field_type: TypeExpression::Identifier {
                        name: "sql.TimestampTZ".to_string(),
                    },
                    optional: false,
                    default: None,
                    entity_id: None,
                    config: json!({}),
                },
            ],
            entity_id: None,
            config: json!({
                "indexes": [
                    {
                        "fields": ["id"],
                        "primary": true
                    }
                ]
            }),
        },
    );

    let schema = Schema {
        type_aliases,
        models,
    };

    let config = json!({
        "dialect": "postgresql",
        "pluralize_table_names": false
    });
    let utils = Utils;

    let files = build(schema, config, &utils);
    let sql = &files[0].content;

    // The id field should use UUID (from template type alias config), not JSONB
    assert!(
        sql.contains("\"id\" UUID NOT NULL"),
        "Expected 'id' column to be UUID, but got:\n{}",
        sql
    );

    // The created_at field should use TIMESTAMPTZ
    assert!(
        sql.contains("\"created_at\" TIMESTAMPTZ NOT NULL"),
        "Expected 'created_at' column to be TIMESTAMPTZ, but got:\n{}",
        sql
    );

    // Should not contain JSONB fallback
    assert!(
        !sql.contains("JSONB"),
        "Should not contain JSONB, but got:\n{}",
        sql
    );
}
