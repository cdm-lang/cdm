use cdm_plugin_interface::{Delta, ModelDefinition, OutputFile, Schema, Utils, JSON};
use crate::utils::{
    extract_indexes, format_default_value, generate_column_definition, generate_create_index_sql,
    generate_create_table, generate_drop_index_sql, get_column_name, get_table_name,
    quote_identifier, should_skip_field, IndexInfo,
};
use crate::type_mapper::{Dialect, TypeMapper};
use std::collections::{HashMap, HashSet};

/// Generates migration files from schema changes
pub fn migrate(
    current_schema: Schema,
    deltas: Vec<Delta>,
    config: JSON,
    _utils: &Utils,
) -> Vec<OutputFile> {
    let mut files = Vec::new();

    if deltas.is_empty() {
        return files;
    }

    let type_mapper = TypeMapper::new(&config, &current_schema.type_aliases);
    let dialect = type_mapper.dialect();

    // Get migration name from config (passed by CDM core)
    let migration_name = config
        .get("migration_name")
        .and_then(|v| v.as_str())
        .unwrap_or("001_migration")
        .to_string();

    // Generate up and down migration contents
    let mut up_content = String::new();
    let mut down_content = String::new();

    up_content.push_str("-- Migration generated by CDM SQL Plugin\n");
    up_content.push_str(&format!("-- Dialect: {:?}\n\n", dialect));

    down_content.push_str("-- Rollback migration generated by CDM SQL Plugin\n");
    down_content.push_str(&format!("-- Dialect: {:?}\n\n", dialect));

    // Sort deltas to ensure tables are created in dependency order (FK dependencies first)
    let sorted_deltas = sort_deltas_by_dependencies(&deltas, &config);

    for delta in &sorted_deltas {
        match delta {
            Delta::ModelAdded { name, after } => {
                // UP: CREATE TABLE
                let table_sql = generate_create_table(name, after, &config, &type_mapper);
                up_content.push_str(&table_sql);
                up_content.push('\n');

                // DOWN: DROP TABLE
                let table_name = get_table_name(name, &after.config, &config);
                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = schema_prefix {
                    format!("{}.{}", quote_identifier(&prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };
                down_content.push_str(&format!("DROP TABLE {};\n\n", full_table_name));
            }

            Delta::ModelRemoved { name, before } => {
                // UP: DROP TABLE
                let table_name = get_table_name(name, &before.config, &config);
                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = schema_prefix {
                    format!("{}.{}", quote_identifier(&prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };
                up_content.push_str(&format!("DROP TABLE {};\n\n", full_table_name));

                // DOWN: CREATE TABLE
                let table_sql = generate_create_table(name, before, &config, &type_mapper);
                down_content.push_str(&table_sql);
                down_content.push('\n');
            }

            Delta::ModelRenamed { old_name, new_name, id: _, before, after } => {
                // UP: RENAME TABLE
                let old_table_name = get_table_name(old_name, &before.config, &config);
                let new_table_name = get_table_name(new_name, &after.config, &config);
                let schema_prefix = get_schema_prefix(&config, dialect);

                match dialect {
                    Dialect::PostgreSQL => {
                        let full_old_name = if let Some(prefix) = &schema_prefix {
                            format!("{}.{}", quote_identifier(prefix, dialect), quote_identifier(&old_table_name, dialect))
                        } else {
                            quote_identifier(&old_table_name, dialect)
                        };
                        up_content.push_str(&format!(
                            "ALTER TABLE {} RENAME TO {};\n\n",
                            full_old_name,
                            quote_identifier(&new_table_name, dialect)
                        ));

                        let full_new_name = if let Some(prefix) = &schema_prefix {
                            format!("{}.{}", quote_identifier(prefix, dialect), quote_identifier(&new_table_name, dialect))
                        } else {
                            quote_identifier(&new_table_name, dialect)
                        };
                        down_content.push_str(&format!(
                            "ALTER TABLE {} RENAME TO {};\n\n",
                            full_new_name,
                            quote_identifier(&old_table_name, dialect)
                        ));
                    }
                    Dialect::SQLite => {
                        up_content.push_str(&format!(
                            "ALTER TABLE {} RENAME TO {};\n\n",
                            quote_identifier(&old_table_name, dialect),
                            quote_identifier(&new_table_name, dialect)
                        ));
                        down_content.push_str(&format!(
                            "ALTER TABLE {} RENAME TO {};\n\n",
                            quote_identifier(&new_table_name, dialect),
                            quote_identifier(&old_table_name, dialect)
                        ));
                    }
                }
            }

            Delta::FieldAdded { model, field, after } => {
                // Skip fields marked with @sql { skip: true }
                if should_skip_field(&after.config) {
                    continue;
                }

                // UP: ALTER TABLE ADD COLUMN
                let field_def = after;
                let table_name = get_table_name(model, &field_def.config, &config);
                let column_name = get_column_name(field, &field_def.config, &config);
                let column_def = generate_column_definition(field_def, &column_name, &config, &type_mapper);

                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = schema_prefix {
                    format!("{}.{}", quote_identifier(&prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };

                up_content.push_str(&format!(
                    "ALTER TABLE {} ADD COLUMN {};\n\n",
                    full_table_name,
                    column_def
                ));

                // DOWN: ALTER TABLE DROP COLUMN
                down_content.push_str(&format!(
                    "ALTER TABLE {} DROP COLUMN {};\n\n",
                    full_table_name,
                    quote_identifier(&column_name, dialect)
                ));
            }

            Delta::FieldRemoved { model, field, before } => {
                // Skip fields marked with @sql { skip: true }
                if should_skip_field(&before.config) {
                    continue;
                }

                // UP: ALTER TABLE DROP COLUMN
                let field_def = before;
                let table_name = get_table_name(model, &field_def.config, &config);
                let column_name = get_column_name(field, &field_def.config, &config);

                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = schema_prefix {
                    format!("{}.{}", quote_identifier(&prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };

                up_content.push_str(&format!(
                    "ALTER TABLE {} DROP COLUMN {};\n\n",
                    full_table_name,
                    quote_identifier(&column_name, dialect)
                ));

                // DOWN: ALTER TABLE ADD COLUMN
                let column_def = generate_column_definition(field_def, &column_name, &config, &type_mapper);
                down_content.push_str(&format!(
                    "ALTER TABLE {} ADD COLUMN {};\n\n",
                    full_table_name,
                    column_def
                ));
            }

            Delta::FieldRenamed { model, old_name, new_name, id: _, before, after } => {
                // Skip fields marked with @sql { skip: true }
                if should_skip_field(&after.config) {
                    continue;
                }

                // UP: RENAME COLUMN
                let table_name = get_table_name(model, &after.config, &config);
                let old_column_name = get_column_name(old_name, &before.config, &config);
                let new_column_name = get_column_name(new_name, &after.config, &config);

                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = &schema_prefix {
                    format!("{}.{}", quote_identifier(prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };

                match dialect {
                    Dialect::PostgreSQL => {
                        up_content.push_str(&format!(
                            "ALTER TABLE {} RENAME COLUMN {} TO {};\n\n",
                            full_table_name,
                            quote_identifier(&old_column_name, dialect),
                            quote_identifier(&new_column_name, dialect)
                        ));
                        down_content.push_str(&format!(
                            "ALTER TABLE {} RENAME COLUMN {} TO {};\n\n",
                            full_table_name,
                            quote_identifier(&new_column_name, dialect),
                            quote_identifier(&old_column_name, dialect)
                        ));
                    }
                    Dialect::SQLite => {
                        // SQLite doesn't support RENAME COLUMN directly in older versions
                        // but does in 3.25.0+, we'll use the modern syntax
                        up_content.push_str(&format!(
                            "ALTER TABLE {} RENAME COLUMN {} TO {};\n\n",
                            full_table_name,
                            quote_identifier(&old_column_name, dialect),
                            quote_identifier(&new_column_name, dialect)
                        ));
                        down_content.push_str(&format!(
                            "ALTER TABLE {} RENAME COLUMN {} TO {};\n\n",
                            full_table_name,
                            quote_identifier(&new_column_name, dialect),
                            quote_identifier(&old_column_name, dialect)
                        ));
                    }
                }
            }

            Delta::FieldTypeChanged { model, field, before, after } => {
                // UP: ALTER COLUMN TYPE
                let model_def = current_schema.models.get(model).unwrap();
                let table_name = get_table_name(model, &model_def.config, &config);
                let field_def = model_def.fields.iter().find(|f| &f.name == field).unwrap();

                // Skip fields marked with @sql { skip: true }
                if should_skip_field(&field_def.config) {
                    continue;
                }

                let column_name = get_column_name(field, &field_def.config, &config);
                let new_type = type_mapper.map_type(after, false);

                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = &schema_prefix {
                    format!("{}.{}", quote_identifier(prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };

                match dialect {
                    Dialect::PostgreSQL => {
                        up_content.push_str(&format!(
                            "ALTER TABLE {} ALTER COLUMN {} TYPE {};\n\n",
                            full_table_name,
                            quote_identifier(&column_name, dialect),
                            new_type
                        ));

                        let old_type = type_mapper.map_type(before, false);
                        down_content.push_str(&format!(
                            "ALTER TABLE {} ALTER COLUMN {} TYPE {};\n\n",
                            full_table_name,
                            quote_identifier(&column_name, dialect),
                            old_type
                        ));
                    }
                    Dialect::SQLite => {
                        // SQLite doesn't support ALTER COLUMN TYPE directly
                        // Users would need to recreate the table or use a workaround
                        up_content.push_str(&format!(
                            "-- SQLite does not support ALTER COLUMN TYPE\n"
                        ));
                        up_content.push_str(&format!(
                            "-- Manual migration required for {}.{} type change\n\n",
                            table_name, column_name
                        ));
                        down_content.push_str(&format!(
                            "-- SQLite does not support ALTER COLUMN TYPE\n"
                        ));
                        down_content.push_str(&format!(
                            "-- Manual migration required for {}.{} type change\n\n",
                            table_name, column_name
                        ));
                    }
                }
            }

            Delta::FieldOptionalityChanged { model, field, before: _, after } => {
                // UP: SET/DROP NOT NULL
                let model_def = current_schema.models.get(model).unwrap();
                let table_name = get_table_name(model, &model_def.config, &config);
                let field_def = model_def.fields.iter().find(|f| &f.name == field).unwrap();

                // Skip fields marked with @sql { skip: true }
                if should_skip_field(&field_def.config) {
                    continue;
                }

                let column_name = get_column_name(field, &field_def.config, &config);

                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = &schema_prefix {
                    format!("{}.{}", quote_identifier(prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };

                match dialect {
                    Dialect::PostgreSQL => {
                        if *after {
                            // Became optional: DROP NOT NULL
                            up_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} DROP NOT NULL;\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect)
                            ));
                            down_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} SET NOT NULL;\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect)
                            ));
                        } else {
                            // Became required: SET NOT NULL
                            up_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} SET NOT NULL;\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect)
                            ));
                            down_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} DROP NOT NULL;\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect)
                            ));
                        }
                    }
                    Dialect::SQLite => {
                        // SQLite doesn't support ALTER COLUMN SET/DROP NOT NULL
                        up_content.push_str(&format!(
                            "-- SQLite does not support ALTER COLUMN SET/DROP NOT NULL\n"
                        ));
                        up_content.push_str(&format!(
                            "-- Manual migration required for {}.{} optionality change\n\n",
                            table_name, column_name
                        ));
                        down_content.push_str(&format!(
                            "-- SQLite does not support ALTER COLUMN SET/DROP NOT NULL\n"
                        ));
                        down_content.push_str(&format!(
                            "-- Manual migration required for {}.{} optionality change\n\n",
                            table_name, column_name
                        ));
                    }
                }
            }

            Delta::FieldDefaultChanged { model, field, before, after } => {
                // UP: SET/DROP DEFAULT
                let model_def = current_schema.models.get(model).unwrap();
                let table_name = get_table_name(model, &model_def.config, &config);
                let field_def = model_def.fields.iter().find(|f| &f.name == field).unwrap();

                // Skip fields marked with @sql { skip: true }
                if should_skip_field(&field_def.config) {
                    continue;
                }

                let column_name = get_column_name(field, &field_def.config, &config);

                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = &schema_prefix {
                    format!("{}.{}", quote_identifier(prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };

                match dialect {
                    Dialect::PostgreSQL => {
                        if let Some(default_value) = after {
                            // Set new default
                            let formatted_default = format_default_value(default_value);
                            up_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} SET DEFAULT {};\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect),
                                formatted_default
                            ));
                        } else {
                            // Drop default
                            up_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} DROP DEFAULT;\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect)
                            ));
                        }

                        if let Some(default_value) = before {
                            // Restore old default
                            let formatted_default = format_default_value(default_value);
                            down_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} SET DEFAULT {};\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect),
                                formatted_default
                            ));
                        } else {
                            // Drop default
                            down_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} DROP DEFAULT;\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect)
                            ));
                        }
                    }
                    Dialect::SQLite => {
                        // SQLite doesn't support ALTER COLUMN SET/DROP DEFAULT
                        up_content.push_str(&format!(
                            "-- SQLite does not support ALTER COLUMN SET/DROP DEFAULT\n"
                        ));
                        up_content.push_str(&format!(
                            "-- Manual migration required for {}.{} default change\n\n",
                            table_name, column_name
                        ));
                        down_content.push_str(&format!(
                            "-- SQLite does not support ALTER COLUMN SET/DROP DEFAULT\n"
                        ));
                        down_content.push_str(&format!(
                            "-- Manual migration required for {}.{} default change\n\n",
                            table_name, column_name
                        ));
                    }
                }
            }

            Delta::TypeAliasAdded { name, after: _ } => {
                // Type aliases don't generate SQL migrations
                up_content.push_str(&format!("-- Type alias added: {}\n\n", name));
                down_content.push_str(&format!("-- Type alias removed: {}\n\n", name));
            }

            Delta::TypeAliasRemoved { name, before: _ } => {
                up_content.push_str(&format!("-- Type alias removed: {}\n\n", name));
                down_content.push_str(&format!("-- Type alias added: {}\n\n", name));
            }

            Delta::TypeAliasRenamed { old_name, new_name, id: _, before: _, after: _ } => {
                up_content.push_str(&format!("-- Type alias renamed: {} -> {}\n\n", old_name, new_name));
                down_content.push_str(&format!("-- Type alias renamed: {} -> {}\n\n", new_name, old_name));
            }

            Delta::TypeAliasTypeChanged { name, before: _, after: _ } => {
                up_content.push_str(&format!("-- Type alias changed: {}\n\n", name));
                down_content.push_str(&format!("-- Type alias changed: {}\n\n", name));
            }

            Delta::InheritanceAdded { model, parent } => {
                // Inheritance changes don't generate direct SQL migrations
                // They affect field flattening which is handled at the model level
                up_content.push_str(&format!("-- Inheritance added: {} extends {}\n\n", model, parent));
                down_content.push_str(&format!("-- Inheritance removed: {} extends {}\n\n", model, parent));
            }

            Delta::InheritanceRemoved { model, parent } => {
                up_content.push_str(&format!("-- Inheritance removed: {} extends {}\n\n", model, parent));
                down_content.push_str(&format!("-- Inheritance added: {} extends {}\n\n", model, parent));
            }

            Delta::GlobalConfigChanged { before: _, after: _ } => {
                up_content.push_str("-- Global config changed\n\n");
                down_content.push_str("-- Global config changed\n\n");
            }

            Delta::ModelConfigChanged { model, before, after } => {
                // Get table info for this model
                if let Some(model_def) = current_schema.models.get(model) {
                    let table_name = get_table_name(model, &model_def.config, &config);
                    let schema_prefix = get_schema_prefix(&config, dialect);
                    let schema_prefix_str = if let Some(prefix) = &schema_prefix {
                        format!("{}.", quote_identifier(prefix, dialect))
                    } else {
                        String::new()
                    };

                    // Extract indexes from before/after configs
                    let before_indexes = extract_indexes(before, &table_name);
                    let after_indexes = extract_indexes(after, &table_name);

                    // Check if before config had any indexes defined at all
                    // If before had no indexes array, any "new" primary key is likely
                    // just inherited config becoming explicit, not an actual change
                    let before_had_indexes = before.get("indexes").is_some()
                        || before.get("sql").and_then(|s| s.get("indexes")).is_some();

                    // Get primary key from before config for comparison
                    let before_pk: Option<&IndexInfo> = before_indexes.iter().find(|i| i.is_primary);

                    // Find added indexes (in after but not in before)
                    for after_idx in &after_indexes {
                        let exists_in_before = before_indexes.iter().any(|b| indexes_equal(b, after_idx));
                        if !exists_in_before {
                            if after_idx.is_primary {
                                // Only emit "manual migration required" if:
                                // 1. before config explicitly had indexes (so we know what was there)
                                // 2. AND there was a different primary key before (actual PK change)
                                // If before had no indexes defined, this is likely just inherited
                                // config becoming explicit, not an actual PK change
                                let is_actual_pk_change = before_had_indexes &&
                                    before_pk.is_some() &&
                                    !before_pk.map(|pk| indexes_equal(pk, after_idx)).unwrap_or(false);

                                if is_actual_pk_change {
                                    up_content.push_str(&format!(
                                        "-- Primary key change requires manual migration: {}\n\n",
                                        after_idx.name
                                    ));
                                    down_content.push_str(&format!(
                                        "-- Primary key change requires manual migration: {}\n\n",
                                        after_idx.name
                                    ));
                                }
                                // If before had no indexes or no PK, skip the warning
                                // (this is just config representation changing, not actual schema change)
                            } else {
                                // Generate CREATE INDEX for up migration
                                up_content.push_str(&generate_create_index_sql(after_idx, &table_name, &schema_prefix_str, dialect));
                                up_content.push('\n');

                                // Generate DROP INDEX for down migration
                                down_content.push_str(&generate_drop_index_sql(after_idx, &schema_prefix_str, dialect));
                                down_content.push('\n');
                            }
                        }
                    }

                    // Find removed indexes (in before but not in after)
                    for before_idx in &before_indexes {
                        let exists_in_after = after_indexes.iter().any(|a| indexes_equal(before_idx, a));
                        if !exists_in_after {
                            if before_idx.is_primary {
                                // Primary key is being removed - this definitely requires manual migration
                                up_content.push_str(&format!(
                                    "-- Primary key change requires manual migration: {}\n\n",
                                    before_idx.name
                                ));
                                down_content.push_str(&format!(
                                    "-- Primary key change requires manual migration: {}\n\n",
                                    before_idx.name
                                ));
                            } else {
                                // Generate DROP INDEX for up migration
                                up_content.push_str(&generate_drop_index_sql(before_idx, &schema_prefix_str, dialect));
                                up_content.push('\n');

                                // Generate CREATE INDEX for down migration
                                down_content.push_str(&generate_create_index_sql(before_idx, &table_name, &schema_prefix_str, dialect));
                                down_content.push('\n');
                            }
                        }
                    }
                } else {
                    up_content.push_str(&format!("-- Model config changed: {}\n\n", model));
                    down_content.push_str(&format!("-- Model config changed: {}\n\n", model));
                }
            }

            Delta::FieldConfigChanged { model, field, before: _, after: _ } => {
                up_content.push_str(&format!("-- Field config changed: {}.{}\n\n", model, field));
                down_content.push_str(&format!("-- Field config changed: {}.{}\n\n", model, field));
            }
        }
    }

    // Create migration files
    let file_extension = match dialect {
        Dialect::PostgreSQL => "postgres.sql",
        Dialect::SQLite => "sqlite.sql",
    };

    files.push(OutputFile {
        path: format!("{}.up.{}", migration_name, file_extension),
        content: up_content,
    });

    files.push(OutputFile {
        path: format!("{}.down.{}", migration_name, file_extension),
        content: down_content,
    });

    files
}

/// Helper function to get schema prefix from config
fn get_schema_prefix(config: &JSON, dialect: Dialect) -> Option<String> {
    match dialect {
        Dialect::PostgreSQL => config
            .get("schema")
            .and_then(|s| s.as_str())
            .map(|s| s.to_string()),
        Dialect::SQLite => None, // SQLite doesn't support schemas
    }
}

/// Compare two indexes for equality (by fields and type, not name)
fn indexes_equal(a: &IndexInfo, b: &IndexInfo) -> bool {
    a.fields == b.fields
        && a.is_unique == b.is_unique
        && a.is_primary == b.is_primary
        && a.method == b.method
        && a.where_clause == b.where_clause
}

/// Sort deltas to ensure tables are created in dependency order.
/// Tables with foreign key references should be created AFTER the tables they reference.
/// This uses topological sorting based on FK dependencies.
fn sort_deltas_by_dependencies(deltas: &[Delta], config: &JSON) -> Vec<Delta> {
    // Separate ModelAdded deltas from other deltas
    let mut model_added_deltas: Vec<(String, ModelDefinition)> = Vec::new();
    let mut other_deltas: Vec<Delta> = Vec::new();

    for delta in deltas {
        match delta {
            Delta::ModelAdded { name, after } => {
                model_added_deltas.push((name.clone(), after.clone()));
            }
            _ => {
                other_deltas.push(delta.clone());
            }
        }
    }

    // If no ModelAdded deltas or only one, no sorting needed
    if model_added_deltas.len() <= 1 {
        return deltas.to_vec();
    }

    // Build a map from table name to model name for dependency resolution
    let mut table_to_model: HashMap<String, String> = HashMap::new();
    for (model_name, model_def) in &model_added_deltas {
        let table_name = get_table_name(model_name, &model_def.config, config);
        table_to_model.insert(table_name, model_name.clone());
    }

    // Build dependency graph: model_name -> set of model names it depends on
    let mut dependencies: HashMap<String, HashSet<String>> = HashMap::new();
    for (model_name, model_def) in &model_added_deltas {
        let mut deps: HashSet<String> = HashSet::new();
        for field in &model_def.fields {
            if let Some(ref_table) = get_referenced_table(&field.config) {
                // Check if the referenced table is one of the tables being created
                if let Some(dep_model) = table_to_model.get(&ref_table) {
                    // Don't add self-references as dependencies
                    if dep_model != model_name {
                        deps.insert(dep_model.clone());
                    }
                }
            }
        }
        dependencies.insert(model_name.clone(), deps);
    }

    // Topological sort using Kahn's algorithm
    let sorted_model_names = topological_sort(&model_added_deltas, &dependencies);

    // Rebuild the deltas in sorted order
    let model_map: HashMap<String, ModelDefinition> = model_added_deltas.into_iter().collect();
    let mut sorted_deltas: Vec<Delta> = Vec::new();

    // First add the sorted ModelAdded deltas
    for model_name in sorted_model_names {
        if let Some(model_def) = model_map.get(&model_name) {
            sorted_deltas.push(Delta::ModelAdded {
                name: model_name,
                after: model_def.clone(),
            });
        }
    }

    // Then add all other deltas (preserving their original order)
    sorted_deltas.extend(other_deltas);

    sorted_deltas
}

/// Extract the referenced table name from a field config, if any.
/// Extract the referenced table name from a field config, if any.
/// Checks both top-level "references" and nested "sql.references" for compatibility.
fn get_referenced_table(config: &JSON) -> Option<String> {
    // First try top-level references (flattened config from CDM core)
    if let Some(table) = config
        .get("references")
        .and_then(|r| r.get("table"))
        .and_then(|t| t.as_str())
    {
        return Some(table.to_string());
    }

    // Then try nested under "sql" key (original config structure)
    config
        .get("sql")
        .and_then(|sql| sql.get("references"))
        .and_then(|r| r.get("table"))
        .and_then(|t| t.as_str())
        .map(|s| s.to_string())
}

/// Perform topological sort on models based on their dependencies.
/// Uses Kahn's algorithm: repeatedly remove nodes with no incoming edges.
fn topological_sort(
    models: &[(String, ModelDefinition)],
    dependencies: &HashMap<String, HashSet<String>>,
) -> Vec<String> {
    let model_names: HashSet<String> = models.iter().map(|(name, _)| name.clone()).collect();

    // Calculate in-degree for each model (how many models depend on it being created first)
    let mut in_degree: HashMap<String, usize> = HashMap::new();
    for (model_name, _) in models {
        in_degree.insert(model_name.clone(), 0);
    }

    for (_, deps) in dependencies {
        for dep in deps {
            if model_names.contains(dep) {
                *in_degree.entry(dep.clone()).or_insert(0) += 1;
            }
        }
    }

    // Wait, that's calculating it backwards. Let me fix:
    // in_degree should be: for each model, how many OTHER models must be created before it
    in_degree.clear();
    for (model_name, _) in models {
        let deps = dependencies.get(model_name).cloned().unwrap_or_default();
        // Count only dependencies that are in our model set
        let count = deps.iter().filter(|d| model_names.contains(*d)).count();
        in_degree.insert(model_name.clone(), count);
    }

    // Start with models that have no dependencies
    let mut queue: Vec<String> = in_degree
        .iter()
        .filter(|(_, count)| **count == 0)
        .map(|(name, _)| name.clone())
        .collect();

    // Sort the queue for deterministic output
    queue.sort();

    let mut sorted: Vec<String> = Vec::new();

    while let Some(model_name) = queue.pop() {
        sorted.push(model_name.clone());

        // For each model that depends on this one, decrement its in-degree
        for (other_model, deps) in dependencies {
            if deps.contains(&model_name) && model_names.contains(other_model) {
                if let Some(count) = in_degree.get_mut(other_model) {
                    *count = count.saturating_sub(1);
                    if *count == 0 {
                        queue.push(other_model.clone());
                        queue.sort(); // Keep sorted for determinism
                    }
                }
            }
        }
    }

    // If we didn't sort all models, there's a cycle - just return in original order
    if sorted.len() != models.len() {
        return models.iter().map(|(name, _)| name.clone()).collect();
    }

    sorted
}

#[cfg(test)]
#[path = "migrate/migrate_tests.rs"]
mod migrate_tests;
