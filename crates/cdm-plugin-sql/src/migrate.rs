use cdm_plugin_interface::{Delta, FieldDefinition, OutputFile, Schema, Utils, JSON};
use crate::utils::{
    extract_indexes, format_default_value, generate_create_index_sql, generate_create_table,
    generate_drop_index_sql, get_column_name, get_table_name, quote_identifier, IndexInfo,
};
use crate::type_mapper::{Dialect, TypeMapper};

/// Generates migration files from schema changes
pub fn migrate(
    current_schema: Schema,
    deltas: Vec<Delta>,
    config: JSON,
    _utils: &Utils,
) -> Vec<OutputFile> {
    let mut files = Vec::new();

    if deltas.is_empty() {
        return files;
    }

    let type_mapper = TypeMapper::new(&config, &current_schema.type_aliases);
    let dialect = type_mapper.dialect();

    // Generate a simple migration number (would need to be tracked externally)
    let migration_number = "001".to_string();

    // Generate up and down migration contents
    let mut up_content = String::new();
    let mut down_content = String::new();

    up_content.push_str("-- Migration generated by CDM SQL Plugin\n");
    up_content.push_str(&format!("-- Dialect: {:?}\n\n", dialect));

    down_content.push_str("-- Rollback migration generated by CDM SQL Plugin\n");
    down_content.push_str(&format!("-- Dialect: {:?}\n\n", dialect));

    for delta in &deltas {
        match delta {
            Delta::ModelAdded { name, after } => {
                // UP: CREATE TABLE
                let table_sql = generate_create_table(name, after, &config, &type_mapper);
                up_content.push_str(&table_sql);
                up_content.push('\n');

                // DOWN: DROP TABLE
                let table_name = get_table_name(name, &after.config, &config);
                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = schema_prefix {
                    format!("{}.{}", quote_identifier(&prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };
                down_content.push_str(&format!("DROP TABLE {};\n\n", full_table_name));
            }

            Delta::ModelRemoved { name, before } => {
                // UP: DROP TABLE
                let table_name = get_table_name(name, &before.config, &config);
                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = schema_prefix {
                    format!("{}.{}", quote_identifier(&prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };
                up_content.push_str(&format!("DROP TABLE {};\n\n", full_table_name));

                // DOWN: CREATE TABLE
                let table_sql = generate_create_table(name, before, &config, &type_mapper);
                down_content.push_str(&table_sql);
                down_content.push('\n');
            }

            Delta::ModelRenamed { old_name, new_name, id: _, before, after } => {
                // UP: RENAME TABLE
                let old_table_name = get_table_name(old_name, &before.config, &config);
                let new_table_name = get_table_name(new_name, &after.config, &config);
                let schema_prefix = get_schema_prefix(&config, dialect);

                match dialect {
                    Dialect::PostgreSQL => {
                        let full_old_name = if let Some(prefix) = &schema_prefix {
                            format!("{}.{}", quote_identifier(prefix, dialect), quote_identifier(&old_table_name, dialect))
                        } else {
                            quote_identifier(&old_table_name, dialect)
                        };
                        up_content.push_str(&format!(
                            "ALTER TABLE {} RENAME TO {};\n\n",
                            full_old_name,
                            quote_identifier(&new_table_name, dialect)
                        ));

                        let full_new_name = if let Some(prefix) = &schema_prefix {
                            format!("{}.{}", quote_identifier(prefix, dialect), quote_identifier(&new_table_name, dialect))
                        } else {
                            quote_identifier(&new_table_name, dialect)
                        };
                        down_content.push_str(&format!(
                            "ALTER TABLE {} RENAME TO {};\n\n",
                            full_new_name,
                            quote_identifier(&old_table_name, dialect)
                        ));
                    }
                    Dialect::SQLite => {
                        up_content.push_str(&format!(
                            "ALTER TABLE {} RENAME TO {};\n\n",
                            quote_identifier(&old_table_name, dialect),
                            quote_identifier(&new_table_name, dialect)
                        ));
                        down_content.push_str(&format!(
                            "ALTER TABLE {} RENAME TO {};\n\n",
                            quote_identifier(&new_table_name, dialect),
                            quote_identifier(&old_table_name, dialect)
                        ));
                    }
                }
            }

            Delta::FieldAdded { model, field, after } => {
                // UP: ALTER TABLE ADD COLUMN
                let field_def = after;
                let table_name = get_table_name(model, &field_def.config, &config);
                let column_name = get_column_name(field, &field_def.config, &config);
                let column_def = generate_column_definition(field_def, &column_name, &config, &type_mapper);

                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = schema_prefix {
                    format!("{}.{}", quote_identifier(&prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };

                up_content.push_str(&format!(
                    "ALTER TABLE {} ADD COLUMN {};\n\n",
                    full_table_name,
                    column_def
                ));

                // DOWN: ALTER TABLE DROP COLUMN
                down_content.push_str(&format!(
                    "ALTER TABLE {} DROP COLUMN {};\n\n",
                    full_table_name,
                    quote_identifier(&column_name, dialect)
                ));
            }

            Delta::FieldRemoved { model, field, before } => {
                // UP: ALTER TABLE DROP COLUMN
                let field_def = before;
                let table_name = get_table_name(model, &field_def.config, &config);
                let column_name = get_column_name(field, &field_def.config, &config);

                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = schema_prefix {
                    format!("{}.{}", quote_identifier(&prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };

                up_content.push_str(&format!(
                    "ALTER TABLE {} DROP COLUMN {};\n\n",
                    full_table_name,
                    quote_identifier(&column_name, dialect)
                ));

                // DOWN: ALTER TABLE ADD COLUMN
                let column_def = generate_column_definition(field_def, &column_name, &config, &type_mapper);
                down_content.push_str(&format!(
                    "ALTER TABLE {} ADD COLUMN {};\n\n",
                    full_table_name,
                    column_def
                ));
            }

            Delta::FieldRenamed { model, old_name, new_name, id: _, before, after } => {
                // UP: RENAME COLUMN
                let table_name = get_table_name(model, &after.config, &config);
                let old_column_name = get_column_name(old_name, &before.config, &config);
                let new_column_name = get_column_name(new_name, &after.config, &config);

                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = &schema_prefix {
                    format!("{}.{}", quote_identifier(prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };

                match dialect {
                    Dialect::PostgreSQL => {
                        up_content.push_str(&format!(
                            "ALTER TABLE {} RENAME COLUMN {} TO {};\n\n",
                            full_table_name,
                            quote_identifier(&old_column_name, dialect),
                            quote_identifier(&new_column_name, dialect)
                        ));
                        down_content.push_str(&format!(
                            "ALTER TABLE {} RENAME COLUMN {} TO {};\n\n",
                            full_table_name,
                            quote_identifier(&new_column_name, dialect),
                            quote_identifier(&old_column_name, dialect)
                        ));
                    }
                    Dialect::SQLite => {
                        // SQLite doesn't support RENAME COLUMN directly in older versions
                        // but does in 3.25.0+, we'll use the modern syntax
                        up_content.push_str(&format!(
                            "ALTER TABLE {} RENAME COLUMN {} TO {};\n\n",
                            full_table_name,
                            quote_identifier(&old_column_name, dialect),
                            quote_identifier(&new_column_name, dialect)
                        ));
                        down_content.push_str(&format!(
                            "ALTER TABLE {} RENAME COLUMN {} TO {};\n\n",
                            full_table_name,
                            quote_identifier(&new_column_name, dialect),
                            quote_identifier(&old_column_name, dialect)
                        ));
                    }
                }
            }

            Delta::FieldTypeChanged { model, field, before, after } => {
                // UP: ALTER COLUMN TYPE
                let model_def = current_schema.models.get(model).unwrap();
                let table_name = get_table_name(model, &model_def.config, &config);
                let field_def = model_def.fields.iter().find(|f| &f.name == field).unwrap();
                let column_name = get_column_name(field, &field_def.config, &config);
                let new_type = type_mapper.map_type(after, false);

                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = &schema_prefix {
                    format!("{}.{}", quote_identifier(prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };

                match dialect {
                    Dialect::PostgreSQL => {
                        up_content.push_str(&format!(
                            "ALTER TABLE {} ALTER COLUMN {} TYPE {};\n\n",
                            full_table_name,
                            quote_identifier(&column_name, dialect),
                            new_type
                        ));

                        let old_type = type_mapper.map_type(before, false);
                        down_content.push_str(&format!(
                            "ALTER TABLE {} ALTER COLUMN {} TYPE {};\n\n",
                            full_table_name,
                            quote_identifier(&column_name, dialect),
                            old_type
                        ));
                    }
                    Dialect::SQLite => {
                        // SQLite doesn't support ALTER COLUMN TYPE directly
                        // Users would need to recreate the table or use a workaround
                        up_content.push_str(&format!(
                            "-- SQLite does not support ALTER COLUMN TYPE\n"
                        ));
                        up_content.push_str(&format!(
                            "-- Manual migration required for {}.{} type change\n\n",
                            table_name, column_name
                        ));
                        down_content.push_str(&format!(
                            "-- SQLite does not support ALTER COLUMN TYPE\n"
                        ));
                        down_content.push_str(&format!(
                            "-- Manual migration required for {}.{} type change\n\n",
                            table_name, column_name
                        ));
                    }
                }
            }

            Delta::FieldOptionalityChanged { model, field, before: _, after } => {
                // UP: SET/DROP NOT NULL
                let model_def = current_schema.models.get(model).unwrap();
                let table_name = get_table_name(model, &model_def.config, &config);
                let field_def = model_def.fields.iter().find(|f| &f.name == field).unwrap();
                let column_name = get_column_name(field, &field_def.config, &config);

                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = &schema_prefix {
                    format!("{}.{}", quote_identifier(prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };

                match dialect {
                    Dialect::PostgreSQL => {
                        if *after {
                            // Became optional: DROP NOT NULL
                            up_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} DROP NOT NULL;\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect)
                            ));
                            down_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} SET NOT NULL;\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect)
                            ));
                        } else {
                            // Became required: SET NOT NULL
                            up_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} SET NOT NULL;\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect)
                            ));
                            down_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} DROP NOT NULL;\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect)
                            ));
                        }
                    }
                    Dialect::SQLite => {
                        // SQLite doesn't support ALTER COLUMN SET/DROP NOT NULL
                        up_content.push_str(&format!(
                            "-- SQLite does not support ALTER COLUMN SET/DROP NOT NULL\n"
                        ));
                        up_content.push_str(&format!(
                            "-- Manual migration required for {}.{} optionality change\n\n",
                            table_name, column_name
                        ));
                        down_content.push_str(&format!(
                            "-- SQLite does not support ALTER COLUMN SET/DROP NOT NULL\n"
                        ));
                        down_content.push_str(&format!(
                            "-- Manual migration required for {}.{} optionality change\n\n",
                            table_name, column_name
                        ));
                    }
                }
            }

            Delta::FieldDefaultChanged { model, field, before, after } => {
                // UP: SET/DROP DEFAULT
                let model_def = current_schema.models.get(model).unwrap();
                let table_name = get_table_name(model, &model_def.config, &config);
                let field_def = model_def.fields.iter().find(|f| &f.name == field).unwrap();
                let column_name = get_column_name(field, &field_def.config, &config);

                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = &schema_prefix {
                    format!("{}.{}", quote_identifier(prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };

                match dialect {
                    Dialect::PostgreSQL => {
                        if let Some(default_value) = after {
                            // Set new default
                            let formatted_default = format_default_value(default_value);
                            up_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} SET DEFAULT {};\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect),
                                formatted_default
                            ));
                        } else {
                            // Drop default
                            up_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} DROP DEFAULT;\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect)
                            ));
                        }

                        if let Some(default_value) = before {
                            // Restore old default
                            let formatted_default = format_default_value(default_value);
                            down_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} SET DEFAULT {};\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect),
                                formatted_default
                            ));
                        } else {
                            // Drop default
                            down_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} DROP DEFAULT;\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect)
                            ));
                        }
                    }
                    Dialect::SQLite => {
                        // SQLite doesn't support ALTER COLUMN SET/DROP DEFAULT
                        up_content.push_str(&format!(
                            "-- SQLite does not support ALTER COLUMN SET/DROP DEFAULT\n"
                        ));
                        up_content.push_str(&format!(
                            "-- Manual migration required for {}.{} default change\n\n",
                            table_name, column_name
                        ));
                        down_content.push_str(&format!(
                            "-- SQLite does not support ALTER COLUMN SET/DROP DEFAULT\n"
                        ));
                        down_content.push_str(&format!(
                            "-- Manual migration required for {}.{} default change\n\n",
                            table_name, column_name
                        ));
                    }
                }
            }

            Delta::TypeAliasAdded { name, after: _ } => {
                // Type aliases don't generate SQL migrations
                up_content.push_str(&format!("-- Type alias added: {}\n\n", name));
                down_content.push_str(&format!("-- Type alias removed: {}\n\n", name));
            }

            Delta::TypeAliasRemoved { name, before: _ } => {
                up_content.push_str(&format!("-- Type alias removed: {}\n\n", name));
                down_content.push_str(&format!("-- Type alias added: {}\n\n", name));
            }

            Delta::TypeAliasRenamed { old_name, new_name, id: _, before: _, after: _ } => {
                up_content.push_str(&format!("-- Type alias renamed: {} -> {}\n\n", old_name, new_name));
                down_content.push_str(&format!("-- Type alias renamed: {} -> {}\n\n", new_name, old_name));
            }

            Delta::TypeAliasTypeChanged { name, before: _, after: _ } => {
                up_content.push_str(&format!("-- Type alias changed: {}\n\n", name));
                down_content.push_str(&format!("-- Type alias changed: {}\n\n", name));
            }

            Delta::InheritanceAdded { model, parent } => {
                // Inheritance changes don't generate direct SQL migrations
                // They affect field flattening which is handled at the model level
                up_content.push_str(&format!("-- Inheritance added: {} extends {}\n\n", model, parent));
                down_content.push_str(&format!("-- Inheritance removed: {} extends {}\n\n", model, parent));
            }

            Delta::InheritanceRemoved { model, parent } => {
                up_content.push_str(&format!("-- Inheritance removed: {} extends {}\n\n", model, parent));
                down_content.push_str(&format!("-- Inheritance added: {} extends {}\n\n", model, parent));
            }

            Delta::GlobalConfigChanged { before: _, after: _ } => {
                up_content.push_str("-- Global config changed\n\n");
                down_content.push_str("-- Global config changed\n\n");
            }

            Delta::ModelConfigChanged { model, before, after } => {
                // Get table info for this model
                if let Some(model_def) = current_schema.models.get(model) {
                    let table_name = get_table_name(model, &model_def.config, &config);
                    let schema_prefix = get_schema_prefix(&config, dialect);
                    let schema_prefix_str = if let Some(prefix) = &schema_prefix {
                        format!("{}.", quote_identifier(prefix, dialect))
                    } else {
                        String::new()
                    };

                    // Extract indexes from before/after configs
                    let before_indexes = extract_indexes(before, &table_name);
                    let after_indexes = extract_indexes(after, &table_name);

                    // Find added indexes (in after but not in before)
                    for after_idx in &after_indexes {
                        let exists_in_before = before_indexes.iter().any(|b| indexes_equal(b, after_idx));
                        if !exists_in_before {
                            if after_idx.is_primary {
                                // Primary key changes require manual migration
                                up_content.push_str(&format!(
                                    "-- Primary key change requires manual migration: {}\n\n",
                                    after_idx.name
                                ));
                                down_content.push_str(&format!(
                                    "-- Primary key change requires manual migration: {}\n\n",
                                    after_idx.name
                                ));
                            } else {
                                // Generate CREATE INDEX for up migration
                                up_content.push_str(&generate_create_index_sql(after_idx, &table_name, &schema_prefix_str, dialect));
                                up_content.push('\n');

                                // Generate DROP INDEX for down migration
                                down_content.push_str(&generate_drop_index_sql(after_idx, &schema_prefix_str, dialect));
                                down_content.push('\n');
                            }
                        }
                    }

                    // Find removed indexes (in before but not in after)
                    for before_idx in &before_indexes {
                        let exists_in_after = after_indexes.iter().any(|a| indexes_equal(before_idx, a));
                        if !exists_in_after {
                            if before_idx.is_primary {
                                // Primary key changes require manual migration
                                up_content.push_str(&format!(
                                    "-- Primary key change requires manual migration: {}\n\n",
                                    before_idx.name
                                ));
                                down_content.push_str(&format!(
                                    "-- Primary key change requires manual migration: {}\n\n",
                                    before_idx.name
                                ));
                            } else {
                                // Generate DROP INDEX for up migration
                                up_content.push_str(&generate_drop_index_sql(before_idx, &schema_prefix_str, dialect));
                                up_content.push('\n');

                                // Generate CREATE INDEX for down migration
                                down_content.push_str(&generate_create_index_sql(before_idx, &table_name, &schema_prefix_str, dialect));
                                down_content.push('\n');
                            }
                        }
                    }
                } else {
                    up_content.push_str(&format!("-- Model config changed: {}\n\n", model));
                    down_content.push_str(&format!("-- Model config changed: {}\n\n", model));
                }
            }

            Delta::FieldConfigChanged { model, field, before: _, after: _ } => {
                up_content.push_str(&format!("-- Field config changed: {}.{}\n\n", model, field));
                down_content.push_str(&format!("-- Field config changed: {}.{}\n\n", model, field));
            }
        }
    }

    // Create migration files
    let file_extension = match dialect {
        Dialect::PostgreSQL => "postgres.sql",
        Dialect::SQLite => "sqlite.sql",
    };

    files.push(OutputFile {
        path: format!("{}_migration.up.{}", migration_number, file_extension),
        content: up_content,
    });

    files.push(OutputFile {
        path: format!("{}_migration.down.{}", migration_number, file_extension),
        content: down_content,
    });

    files
}

/// Helper function to get schema prefix from config
fn get_schema_prefix(config: &JSON, dialect: Dialect) -> Option<String> {
    match dialect {
        Dialect::PostgreSQL => config
            .get("schema")
            .and_then(|s| s.as_str())
            .map(|s| s.to_string()),
        Dialect::SQLite => None, // SQLite doesn't support schemas
    }
}

/// Helper function to generate column definition for ALTER TABLE ADD COLUMN
fn generate_column_definition(
    field: &FieldDefinition,
    column_name: &str,
    config: &JSON,
    type_mapper: &TypeMapper,
) -> String {
    let dialect = type_mapper.dialect();
    let mut parts = vec![quote_identifier(column_name, dialect)];

    // Check for type override in field config
    let sql_type = field
        .config
        .get("type")
        .and_then(|t| t.as_str())
        .map(|s| s.to_string())
        .unwrap_or_else(|| type_mapper.map_type(&field.field_type, field.optional));

    parts.push(sql_type);

    // Handle NOT NULL
    let infer_not_null = config
        .get("infer_not_null")
        .and_then(|v| v.as_bool())
        .unwrap_or(true);

    if infer_not_null && !field.optional {
        parts.push("NOT NULL".to_string());
    }

    // Handle DEFAULT
    let apply_defaults = config
        .get("apply_cdm_defaults")
        .and_then(|v| v.as_bool())
        .unwrap_or(false);

    if apply_defaults {
        if let Some(default) = &field.default {
            let formatted_default = format_default_value(default);
            parts.push(format!("DEFAULT {}", formatted_default));
        }
    }

    parts.join(" ")
}

/// Compare two indexes for equality (by fields and type, not name)
fn indexes_equal(a: &IndexInfo, b: &IndexInfo) -> bool {
    a.fields == b.fields
        && a.is_unique == b.is_unique
        && a.is_primary == b.is_primary
        && a.method == b.method
        && a.where_clause == b.where_clause
}

#[cfg(test)]
#[path = "migrate/migrate_tests.rs"]
mod migrate_tests;
