use cdm_plugin_interface::{Delta, FieldDefinition, OutputFile, Schema, Utils, JSON};
use crate::utils::{
    format_default_value, generate_create_table, get_column_name,
    get_table_name, quote_identifier,
};
use crate::type_mapper::{Dialect, TypeMapper};

/// Generates migration files from schema changes
pub fn migrate(
    current_schema: Schema,
    deltas: Vec<Delta>,
    config: JSON,
    _utils: &Utils,
) -> Vec<OutputFile> {
    let mut files = Vec::new();

    if deltas.is_empty() {
        return files;
    }

    let type_mapper = TypeMapper::new(&config);
    let dialect = type_mapper.dialect();

    // Generate a simple migration number (would need to be tracked externally)
    let migration_number = "001".to_string();

    // Generate up and down migration contents
    let mut up_content = String::new();
    let mut down_content = String::new();

    up_content.push_str("-- Migration generated by CDM SQL Plugin\n");
    up_content.push_str(&format!("-- Dialect: {:?}\n\n", dialect));

    down_content.push_str("-- Rollback migration generated by CDM SQL Plugin\n");
    down_content.push_str(&format!("-- Dialect: {:?}\n\n", dialect));

    for delta in &deltas {
        match delta {
            Delta::ModelAdded { name, after } => {
                // UP: CREATE TABLE
                let table_sql = generate_create_table(name, after, &config, &type_mapper);
                up_content.push_str(&table_sql);
                up_content.push('\n');

                // DOWN: DROP TABLE
                let table_name = get_table_name(name, &after.config, &config);
                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = schema_prefix {
                    format!("{}.{}", quote_identifier(&prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };
                down_content.push_str(&format!("DROP TABLE {};\n\n", full_table_name));
            }

            Delta::ModelRemoved { name, before } => {
                // UP: DROP TABLE
                let table_name = get_table_name(name, &before.config, &config);
                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = schema_prefix {
                    format!("{}.{}", quote_identifier(&prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };
                up_content.push_str(&format!("DROP TABLE {};\n\n", full_table_name));

                // DOWN: CREATE TABLE
                let table_sql = generate_create_table(name, before, &config, &type_mapper);
                down_content.push_str(&table_sql);
                down_content.push('\n');
            }

            Delta::ModelRenamed { old_name, new_name, id, before, after } => {
                // UP: RENAME TABLE
                let old_table_name = get_table_name(old_name, &before.config, &config);
                let new_table_name = get_table_name(new_name, &after.config, &config);
                let schema_prefix = get_schema_prefix(&config, dialect);

                match dialect {
                    Dialect::PostgreSQL => {
                        let full_old_name = if let Some(prefix) = &schema_prefix {
                            format!("{}.{}", quote_identifier(prefix, dialect), quote_identifier(&old_table_name, dialect))
                        } else {
                            quote_identifier(&old_table_name, dialect)
                        };
                        up_content.push_str(&format!(
                            "ALTER TABLE {} RENAME TO {};\n\n",
                            full_old_name,
                            quote_identifier(&new_table_name, dialect)
                        ));

                        let full_new_name = if let Some(prefix) = &schema_prefix {
                            format!("{}.{}", quote_identifier(prefix, dialect), quote_identifier(&new_table_name, dialect))
                        } else {
                            quote_identifier(&new_table_name, dialect)
                        };
                        down_content.push_str(&format!(
                            "ALTER TABLE {} RENAME TO {};\n\n",
                            full_new_name,
                            quote_identifier(&old_table_name, dialect)
                        ));
                    }
                    Dialect::SQLite => {
                        up_content.push_str(&format!(
                            "ALTER TABLE {} RENAME TO {};\n\n",
                            quote_identifier(&old_table_name, dialect),
                            quote_identifier(&new_table_name, dialect)
                        ));
                        down_content.push_str(&format!(
                            "ALTER TABLE {} RENAME TO {};\n\n",
                            quote_identifier(&new_table_name, dialect),
                            quote_identifier(&old_table_name, dialect)
                        ));
                    }
                }
            }

            Delta::FieldAdded { model, field, after } => {
                // UP: ALTER TABLE ADD COLUMN
                let field_def = after;
                let table_name = get_table_name(model, &field_def.config, &config);
                let column_name = get_column_name(field, &field_def.config, &config);
                let column_def = generate_column_definition(field_def, &column_name, &config, &type_mapper);

                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = schema_prefix {
                    format!("{}.{}", quote_identifier(&prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };

                up_content.push_str(&format!(
                    "ALTER TABLE {} ADD COLUMN {};\n\n",
                    full_table_name,
                    column_def
                ));

                // DOWN: ALTER TABLE DROP COLUMN
                down_content.push_str(&format!(
                    "ALTER TABLE {} DROP COLUMN {};\n\n",
                    full_table_name,
                    quote_identifier(&column_name, dialect)
                ));
            }

            Delta::FieldRemoved { model, field, before } => {
                // UP: ALTER TABLE DROP COLUMN
                let field_def = before;
                let table_name = get_table_name(model, &field_def.config, &config);
                let column_name = get_column_name(field, &field_def.config, &config);

                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = schema_prefix {
                    format!("{}.{}", quote_identifier(&prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };

                up_content.push_str(&format!(
                    "ALTER TABLE {} DROP COLUMN {};\n\n",
                    full_table_name,
                    quote_identifier(&column_name, dialect)
                ));

                // DOWN: ALTER TABLE ADD COLUMN
                let column_def = generate_column_definition(field_def, &column_name, &config, &type_mapper);
                down_content.push_str(&format!(
                    "ALTER TABLE {} ADD COLUMN {};\n\n",
                    full_table_name,
                    column_def
                ));
            }

            Delta::FieldRenamed { model, old_name, new_name, id, before, after } => {
                // UP: RENAME COLUMN
                let table_name = get_table_name(model, &after.config, &config);
                let old_column_name = get_column_name(old_name, &before.config, &config);
                let new_column_name = get_column_name(new_name, &after.config, &config);

                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = &schema_prefix {
                    format!("{}.{}", quote_identifier(prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };

                match dialect {
                    Dialect::PostgreSQL => {
                        up_content.push_str(&format!(
                            "ALTER TABLE {} RENAME COLUMN {} TO {};\n\n",
                            full_table_name,
                            quote_identifier(&old_column_name, dialect),
                            quote_identifier(&new_column_name, dialect)
                        ));
                        down_content.push_str(&format!(
                            "ALTER TABLE {} RENAME COLUMN {} TO {};\n\n",
                            full_table_name,
                            quote_identifier(&new_column_name, dialect),
                            quote_identifier(&old_column_name, dialect)
                        ));
                    }
                    Dialect::SQLite => {
                        // SQLite doesn't support RENAME COLUMN directly in older versions
                        // but does in 3.25.0+, we'll use the modern syntax
                        up_content.push_str(&format!(
                            "ALTER TABLE {} RENAME COLUMN {} TO {};\n\n",
                            full_table_name,
                            quote_identifier(&old_column_name, dialect),
                            quote_identifier(&new_column_name, dialect)
                        ));
                        down_content.push_str(&format!(
                            "ALTER TABLE {} RENAME COLUMN {} TO {};\n\n",
                            full_table_name,
                            quote_identifier(&new_column_name, dialect),
                            quote_identifier(&old_column_name, dialect)
                        ));
                    }
                }
            }

            Delta::FieldTypeChanged { model, field, before, after } => {
                // UP: ALTER COLUMN TYPE
                let model_def = current_schema.models.get(model).unwrap();
                let table_name = get_table_name(model, &model_def.config, &config);
                let field_def = model_def.fields.iter().find(|f| &f.name == field).unwrap();
                let column_name = get_column_name(field, &field_def.config, &config);
                let new_type = type_mapper.map_type(after, false);

                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = &schema_prefix {
                    format!("{}.{}", quote_identifier(prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };

                match dialect {
                    Dialect::PostgreSQL => {
                        up_content.push_str(&format!(
                            "ALTER TABLE {} ALTER COLUMN {} TYPE {};\n\n",
                            full_table_name,
                            quote_identifier(&column_name, dialect),
                            new_type
                        ));

                        let old_type = type_mapper.map_type(before, false);
                        down_content.push_str(&format!(
                            "ALTER TABLE {} ALTER COLUMN {} TYPE {};\n\n",
                            full_table_name,
                            quote_identifier(&column_name, dialect),
                            old_type
                        ));
                    }
                    Dialect::SQLite => {
                        // SQLite doesn't support ALTER COLUMN TYPE directly
                        // Users would need to recreate the table or use a workaround
                        up_content.push_str(&format!(
                            "-- SQLite does not support ALTER COLUMN TYPE\n"
                        ));
                        up_content.push_str(&format!(
                            "-- Manual migration required for {}.{} type change\n\n",
                            table_name, column_name
                        ));
                        down_content.push_str(&format!(
                            "-- SQLite does not support ALTER COLUMN TYPE\n"
                        ));
                        down_content.push_str(&format!(
                            "-- Manual migration required for {}.{} type change\n\n",
                            table_name, column_name
                        ));
                    }
                }
            }

            Delta::FieldOptionalityChanged { model, field, before, after } => {
                // UP: SET/DROP NOT NULL
                let model_def = current_schema.models.get(model).unwrap();
                let table_name = get_table_name(model, &model_def.config, &config);
                let field_def = model_def.fields.iter().find(|f| &f.name == field).unwrap();
                let column_name = get_column_name(field, &field_def.config, &config);

                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = &schema_prefix {
                    format!("{}.{}", quote_identifier(prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };

                match dialect {
                    Dialect::PostgreSQL => {
                        if *after {
                            // Became optional: DROP NOT NULL
                            up_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} DROP NOT NULL;\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect)
                            ));
                            down_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} SET NOT NULL;\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect)
                            ));
                        } else {
                            // Became required: SET NOT NULL
                            up_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} SET NOT NULL;\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect)
                            ));
                            down_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} DROP NOT NULL;\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect)
                            ));
                        }
                    }
                    Dialect::SQLite => {
                        // SQLite doesn't support ALTER COLUMN SET/DROP NOT NULL
                        up_content.push_str(&format!(
                            "-- SQLite does not support ALTER COLUMN SET/DROP NOT NULL\n"
                        ));
                        up_content.push_str(&format!(
                            "-- Manual migration required for {}.{} optionality change\n\n",
                            table_name, column_name
                        ));
                        down_content.push_str(&format!(
                            "-- SQLite does not support ALTER COLUMN SET/DROP NOT NULL\n"
                        ));
                        down_content.push_str(&format!(
                            "-- Manual migration required for {}.{} optionality change\n\n",
                            table_name, column_name
                        ));
                    }
                }
            }

            Delta::FieldDefaultChanged { model, field, before, after } => {
                // UP: SET/DROP DEFAULT
                let model_def = current_schema.models.get(model).unwrap();
                let table_name = get_table_name(model, &model_def.config, &config);
                let field_def = model_def.fields.iter().find(|f| &f.name == field).unwrap();
                let column_name = get_column_name(field, &field_def.config, &config);

                let schema_prefix = get_schema_prefix(&config, dialect);
                let full_table_name = if let Some(prefix) = &schema_prefix {
                    format!("{}.{}", quote_identifier(prefix, dialect), quote_identifier(&table_name, dialect))
                } else {
                    quote_identifier(&table_name, dialect)
                };

                match dialect {
                    Dialect::PostgreSQL => {
                        if let Some(default_value) = after {
                            // Set new default
                            let formatted_default = format_default_value(default_value);
                            up_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} SET DEFAULT {};\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect),
                                formatted_default
                            ));
                        } else {
                            // Drop default
                            up_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} DROP DEFAULT;\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect)
                            ));
                        }

                        if let Some(default_value) = before {
                            // Restore old default
                            let formatted_default = format_default_value(default_value);
                            down_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} SET DEFAULT {};\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect),
                                formatted_default
                            ));
                        } else {
                            // Drop default
                            down_content.push_str(&format!(
                                "ALTER TABLE {} ALTER COLUMN {} DROP DEFAULT;\n\n",
                                full_table_name,
                                quote_identifier(&column_name, dialect)
                            ));
                        }
                    }
                    Dialect::SQLite => {
                        // SQLite doesn't support ALTER COLUMN SET/DROP DEFAULT
                        up_content.push_str(&format!(
                            "-- SQLite does not support ALTER COLUMN SET/DROP DEFAULT\n"
                        ));
                        up_content.push_str(&format!(
                            "-- Manual migration required for {}.{} default change\n\n",
                            table_name, column_name
                        ));
                        down_content.push_str(&format!(
                            "-- SQLite does not support ALTER COLUMN SET/DROP DEFAULT\n"
                        ));
                        down_content.push_str(&format!(
                            "-- Manual migration required for {}.{} default change\n\n",
                            table_name, column_name
                        ));
                    }
                }
            }

            Delta::TypeAliasAdded { name, after } => {
                // Type aliases don't generate SQL migrations
                up_content.push_str(&format!("-- Type alias added: {}\n\n", name));
                down_content.push_str(&format!("-- Type alias removed: {}\n\n", name));
            }

            Delta::TypeAliasRemoved { name, before } => {
                up_content.push_str(&format!("-- Type alias removed: {}\n\n", name));
                down_content.push_str(&format!("-- Type alias added: {}\n\n", name));
            }

            Delta::TypeAliasRenamed { old_name, new_name, id, before, after } => {
                up_content.push_str(&format!("-- Type alias renamed: {} -> {}\n\n", old_name, new_name));
                down_content.push_str(&format!("-- Type alias renamed: {} -> {}\n\n", new_name, old_name));
            }

            Delta::TypeAliasTypeChanged { name, before, after } => {
                up_content.push_str(&format!("-- Type alias changed: {}\n\n", name));
                down_content.push_str(&format!("-- Type alias changed: {}\n\n", name));
            }

            Delta::InheritanceAdded { model, parent } => {
                // Inheritance changes don't generate direct SQL migrations
                // They affect field flattening which is handled at the model level
                up_content.push_str(&format!("-- Inheritance added: {} extends {}\n\n", model, parent));
                down_content.push_str(&format!("-- Inheritance removed: {} extends {}\n\n", model, parent));
            }

            Delta::InheritanceRemoved { model, parent } => {
                up_content.push_str(&format!("-- Inheritance removed: {} extends {}\n\n", model, parent));
                down_content.push_str(&format!("-- Inheritance added: {} extends {}\n\n", model, parent));
            }

            Delta::GlobalConfigChanged { before, after } => {
                up_content.push_str("-- Global config changed\n\n");
                down_content.push_str("-- Global config changed\n\n");
            }

            Delta::ModelConfigChanged { model, before, after } => {
                up_content.push_str(&format!("-- Model config changed: {}\n\n", model));
                down_content.push_str(&format!("-- Model config changed: {}\n\n", model));
            }

            Delta::FieldConfigChanged { model, field, before, after } => {
                up_content.push_str(&format!("-- Field config changed: {}.{}\n\n", model, field));
                down_content.push_str(&format!("-- Field config changed: {}.{}\n\n", model, field));
            }
        }
    }

    // Create migration files
    let file_extension = match dialect {
        Dialect::PostgreSQL => "postgres.sql",
        Dialect::SQLite => "sqlite.sql",
    };

    files.push(OutputFile {
        path: format!("{}_migration.up.{}", migration_number, file_extension),
        content: up_content,
    });

    files.push(OutputFile {
        path: format!("{}_migration.down.{}", migration_number, file_extension),
        content: down_content,
    });

    files
}

/// Helper function to get schema prefix from config
fn get_schema_prefix(config: &JSON, dialect: Dialect) -> Option<String> {
    match dialect {
        Dialect::PostgreSQL => config
            .get("schema")
            .and_then(|s| s.as_str())
            .map(|s| s.to_string()),
        Dialect::SQLite => None, // SQLite doesn't support schemas
    }
}

/// Helper function to generate column definition for ALTER TABLE ADD COLUMN
fn generate_column_definition(
    field: &FieldDefinition,
    column_name: &str,
    config: &JSON,
    type_mapper: &TypeMapper,
) -> String {
    let dialect = type_mapper.dialect();
    let mut parts = vec![quote_identifier(column_name, dialect)];

    // Check for type override in field config
    let sql_type = field
        .config
        .get("type")
        .and_then(|t| t.as_str())
        .map(|s| s.to_string())
        .unwrap_or_else(|| type_mapper.map_type(&field.field_type, field.optional));

    parts.push(sql_type);

    // Handle NOT NULL
    let infer_not_null = config
        .get("infer_not_null")
        .and_then(|v| v.as_bool())
        .unwrap_or(true);

    if infer_not_null && !field.optional {
        parts.push("NOT NULL".to_string());
    }

    // Handle DEFAULT
    let apply_defaults = config
        .get("apply_cdm_defaults")
        .and_then(|v| v.as_bool())
        .unwrap_or(false);

    if apply_defaults {
        if let Some(default) = &field.default {
            let formatted_default = format_default_value(default);
            parts.push(format!("DEFAULT {}", formatted_default));
        }
    }

    parts.join(" ")
}

#[cfg(test)]
mod tests {
    use super::*;
    use cdm_plugin_interface::{FieldDefinition, ModelDefinition};
    use std::collections::HashMap;

    #[test]
    fn test_migrate_empty() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let config = serde_json::json!({});
        let utils = Utils;

        let files = migrate(schema, vec![], config, &utils);
        assert!(files.is_empty());
    }

    #[test]
    fn test_migrate_with_deltas() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let deltas = vec![Delta::ModelAdded {
            name: "User".to_string(),
            after: ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({}),
            },
        }];

        let config = serde_json::json!({});
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2); // up and down migrations

        // Check up migration
        assert!(files[0].path.contains("up"));
        assert!(files[0].content.contains("CREATE TABLE"));

        // Check down migration
        assert!(files[1].path.contains("down"));
        assert!(files[1].content.contains("DROP TABLE"));
    }

    #[test]
    fn test_migrate_field_added_postgres() {
        use cdm_plugin_interface::TypeExpression;

        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![FieldDefinition {
                    name: "name".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: None,
                    config: serde_json::json!({}),
                    entity_id: Some(2),
                }],
                config: serde_json::json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let deltas = vec![Delta::FieldAdded {
            model: "User".to_string(),
            field: "email".to_string(),
            after: FieldDefinition {
                name: "email".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "string".to_string(),
                },
                optional: false,
                default: None,
                config: serde_json::json!({}),
                entity_id: Some(3),
            },
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check up migration contains ADD COLUMN
        assert!(files[0].content.contains("ADD COLUMN"));
        assert!(files[0].content.contains("\"email\""));

        // Check down migration contains DROP COLUMN
        assert!(files[1].content.contains("DROP COLUMN"));
        assert!(files[1].content.contains("\"email\""));
    }

    #[test]
    fn test_migrate_field_renamed_postgres() {
        use cdm_plugin_interface::TypeExpression;

        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![FieldDefinition {
                    name: "full_name".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: None,
                    config: serde_json::json!({}),
                    entity_id: Some(2),
                }],
                config: serde_json::json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let deltas = vec![Delta::FieldRenamed {
            model: "User".to_string(),
            old_name: "name".to_string(),
            new_name: "full_name".to_string(),
            id: Some(2),
            before: FieldDefinition {
                name: "name".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "string".to_string(),
                },
                optional: false,
                default: None,
                config: serde_json::json!({}),
                entity_id: Some(2),
            },
            after: FieldDefinition {
                name: "full_name".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "string".to_string(),
                },
                optional: false,
                default: None,
                config: serde_json::json!({}),
                entity_id: Some(2),
            },
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check up migration renames column
        assert!(files[0].content.contains("RENAME COLUMN"));
        assert!(files[0].content.contains("\"name\""));
        assert!(files[0].content.contains("\"full_name\""));
    }

    #[test]
    fn test_migrate_model_removed_postgres() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let deltas = vec![Delta::ModelRemoved {
            name: "User".to_string(),
            before: ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({}),
            },
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check up migration drops table
        assert!(files[0].content.contains("DROP TABLE"));

        // Check down migration creates table
        assert!(files[1].content.contains("CREATE TABLE"));
    }

    #[test]
    fn test_migrate_field_type_changed_sqlite() {
        use cdm_plugin_interface::TypeExpression;

        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![FieldDefinition {
                    name: "age".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: None,
                    config: serde_json::json!({}),
                    entity_id: Some(2),
                }],
                config: serde_json::json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let deltas = vec![Delta::FieldTypeChanged {
            model: "User".to_string(),
            field: "age".to_string(),
            before: TypeExpression::Identifier {
                name: "number".to_string(),
            },
            after: TypeExpression::Identifier {
                name: "string".to_string(),
            },
        }];

        let config = serde_json::json!({ "dialect": "sqlite", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // SQLite doesn't support ALTER COLUMN TYPE, so should have comments
        assert!(files[0].content.contains("SQLite does not support"));
        assert!(files[0].content.contains("Manual migration required"));
    }

    #[test]
    fn test_migrate_optionality_changed_postgres() {
        use cdm_plugin_interface::TypeExpression;

        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![FieldDefinition {
                    name: "email".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: true,
                    default: None,
                    config: serde_json::json!({}),
                    entity_id: Some(2),
                }],
                config: serde_json::json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let deltas = vec![Delta::FieldOptionalityChanged {
            model: "User".to_string(),
            field: "email".to_string(),
            before: false, // was required
            after: true,   // became optional
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check up migration drops NOT NULL
        assert!(files[0].content.contains("DROP NOT NULL"));

        // Check down migration sets NOT NULL
        assert!(files[1].content.contains("SET NOT NULL"));
    }

    #[test]
    fn test_migrate_default_changed_postgres() {
        use cdm_plugin_interface::{TypeExpression, Value};

        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![FieldDefinition {
                    name: "status".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: Some(Value::String("active".to_string())),
                    config: serde_json::json!({}),
                    entity_id: Some(2),
                }],
                config: serde_json::json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let deltas = vec![Delta::FieldDefaultChanged {
            model: "User".to_string(),
            field: "status".to_string(),
            before: Some(Value::String("pending".to_string())),
            after: Some(Value::String("active".to_string())),
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check up migration sets new default
        assert!(files[0].content.contains("SET DEFAULT"));
        assert!(files[0].content.contains("'active'"));

        // Check down migration sets old default
        assert!(files[1].content.contains("SET DEFAULT"));
        assert!(files[1].content.contains("'pending'"));
    }

    #[test]
    fn test_migrate_default_removed_postgres() {
        use cdm_plugin_interface::{TypeExpression, Value};

        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![FieldDefinition {
                    name: "status".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: None,
                    config: serde_json::json!({}),
                    entity_id: Some(2),
                }],
                config: serde_json::json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let deltas = vec![Delta::FieldDefaultChanged {
            model: "User".to_string(),
            field: "status".to_string(),
            before: Some(Value::String("active".to_string())),
            after: None,
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check up migration drops default
        assert!(files[0].content.contains("DROP DEFAULT"));

        // Check down migration restores default
        assert!(files[1].content.contains("SET DEFAULT"));
        assert!(files[1].content.contains("'active'"));
    }

    #[test]
    fn test_migrate_model_renamed_postgres() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let deltas = vec![Delta::ModelRenamed {
            old_name: "User".to_string(),
            new_name: "Account".to_string(),
            id: Some(1),
            before: ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({}),
            },
            after: ModelDefinition {
                name: "Account".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({}),
            },
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check up migration renames table
        assert!(files[0].content.contains("RENAME TO"));
        assert!(files[0].content.contains("\"user\""));
        assert!(files[0].content.contains("\"account\""));

        // Check down migration reverses rename
        assert!(files[1].content.contains("RENAME TO"));
        assert!(files[1].content.contains("\"account\""));
        assert!(files[1].content.contains("\"user\""));
    }

    #[test]
    fn test_migrate_model_renamed_sqlite() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let deltas = vec![Delta::ModelRenamed {
            old_name: "User".to_string(),
            new_name: "Account".to_string(),
            id: Some(1),
            before: ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({}),
            },
            after: ModelDefinition {
                name: "Account".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({}),
            },
        }];

        let config = serde_json::json!({ "dialect": "sqlite", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check SQLite format (no schema prefix)
        assert!(files[0].content.contains("ALTER TABLE \"user\" RENAME TO \"account\""));
        assert!(files[1].content.contains("ALTER TABLE \"account\" RENAME TO \"user\""));
    }

    #[test]
    fn test_migrate_field_renamed_sqlite() {
        use cdm_plugin_interface::TypeExpression;

        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![FieldDefinition {
                    name: "full_name".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: None,
                    config: serde_json::json!({}),
                    entity_id: Some(2),
                }],
                config: serde_json::json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let deltas = vec![Delta::FieldRenamed {
            model: "User".to_string(),
            old_name: "name".to_string(),
            new_name: "full_name".to_string(),
            id: Some(2),
            before: FieldDefinition {
                name: "name".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "string".to_string(),
                },
                optional: false,
                default: None,
                config: serde_json::json!({}),
                entity_id: Some(2),
            },
            after: FieldDefinition {
                name: "full_name".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "string".to_string(),
                },
                optional: false,
                default: None,
                config: serde_json::json!({}),
                entity_id: Some(2),
            },
        }];

        let config = serde_json::json!({ "dialect": "sqlite", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // SQLite supports RENAME COLUMN in 3.25.0+
        assert!(files[0].content.contains("RENAME COLUMN"));
        assert!(files[0].content.contains("\"name\""));
        assert!(files[0].content.contains("\"full_name\""));
    }

    #[test]
    fn test_migrate_field_type_changed_postgres() {
        use cdm_plugin_interface::TypeExpression;

        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![FieldDefinition {
                    name: "age".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: None,
                    config: serde_json::json!({}),
                    entity_id: Some(2),
                }],
                config: serde_json::json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let deltas = vec![Delta::FieldTypeChanged {
            model: "User".to_string(),
            field: "age".to_string(),
            before: TypeExpression::Identifier {
                name: "number".to_string(),
            },
            after: TypeExpression::Identifier {
                name: "string".to_string(),
            },
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // PostgreSQL supports ALTER COLUMN TYPE
        assert!(files[0].content.contains("ALTER COLUMN"));
        assert!(files[0].content.contains("TYPE"));
        assert!(files[0].content.contains("VARCHAR(255)"));

        // Down migration reverts type
        assert!(files[1].content.contains("DOUBLE PRECISION"));
    }

    #[test]
    fn test_migrate_with_schema_prefix_postgres() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let deltas = vec![Delta::ModelAdded {
            name: "User".to_string(),
            after: ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({}),
            },
        }];

        let config = serde_json::json!({
            "dialect": "postgresql",
            "schema": "public",
            "pluralize_table_names": false
        });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check up migration includes schema prefix
        assert!(files[0].content.contains("\"public\".\"user\""));

        // Check down migration includes schema prefix
        assert!(files[1].content.contains("DROP TABLE \"public\".\"user\""));
    }

    #[test]
    fn test_migrate_with_name_formatting() {
        use cdm_plugin_interface::TypeExpression;

        let mut models = HashMap::new();
        models.insert(
            "UserProfile".to_string(),
            ModelDefinition {
                name: "UserProfile".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![FieldDefinition {
                    name: "firstName".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: None,
                    config: serde_json::json!({}),
                    entity_id: Some(2),
                }],
                config: serde_json::json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let deltas = vec![Delta::FieldAdded {
            model: "UserProfile".to_string(),
            field: "lastName".to_string(),
            after: FieldDefinition {
                name: "lastName".to_string(),
                field_type: TypeExpression::Identifier {
                    name: "string".to_string(),
                },
                optional: false,
                default: None,
                config: serde_json::json!({}),
                entity_id: Some(3),
            },
        }];

        let config = serde_json::json!({
            "dialect": "postgresql",
            "table_name_format": "snake_case",
            "column_name_format": "snake_case",
            "pluralize_table_names": false
        });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check that names are formatted as snake_case
        assert!(files[0].content.contains("\"user_profile\""));
        assert!(files[0].content.contains("\"last_name\""));
    }

    #[test]
    fn test_migrate_optionality_changed_required_to_optional() {
        use cdm_plugin_interface::TypeExpression;

        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![FieldDefinition {
                    name: "email".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: true,
                    default: None,
                    config: serde_json::json!({}),
                    entity_id: Some(2),
                }],
                config: serde_json::json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let deltas = vec![Delta::FieldOptionalityChanged {
            model: "User".to_string(),
            field: "email".to_string(),
            before: false, // was required
            after: true,   // became optional
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Field became optional, so DROP NOT NULL
        assert!(files[0].content.contains("DROP NOT NULL"));
        assert!(files[1].content.contains("SET NOT NULL"));
    }

    #[test]
    fn test_migrate_optionality_changed_optional_to_required() {
        use cdm_plugin_interface::TypeExpression;

        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![FieldDefinition {
                    name: "email".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: None,
                    config: serde_json::json!({}),
                    entity_id: Some(2),
                }],
                config: serde_json::json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let deltas = vec![Delta::FieldOptionalityChanged {
            model: "User".to_string(),
            field: "email".to_string(),
            before: true,  // was optional
            after: false,  // became required
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Field became required, so SET NOT NULL
        assert!(files[0].content.contains("SET NOT NULL"));
        assert!(files[1].content.contains("DROP NOT NULL"));
    }

    #[test]
    fn test_migrate_sqlite_limitations() {
        use cdm_plugin_interface::{TypeExpression, Value};

        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![FieldDefinition {
                    name: "status".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: None,
                    config: serde_json::json!({}),
                    entity_id: Some(2),
                }],
                config: serde_json::json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        // Test multiple SQLite limitations
        let deltas = vec![
            Delta::FieldOptionalityChanged {
                model: "User".to_string(),
                field: "status".to_string(),
                before: false,
                after: true,
            },
            Delta::FieldDefaultChanged {
                model: "User".to_string(),
                field: "status".to_string(),
                before: None,
                after: Some(Value::String("active".to_string())),
            },
        ];

        let config = serde_json::json!({ "dialect": "sqlite", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // All should have manual migration warnings
        let up_content = &files[0].content;
        assert!(up_content.contains("SQLite does not support"));
        assert!(up_content.contains("Manual migration required"));
    }

    #[test]
    fn test_migrate_multiple_deltas() {
        use cdm_plugin_interface::TypeExpression;

        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![
                    FieldDefinition {
                        name: "id".to_string(),
                        field_type: TypeExpression::Identifier {
                            name: "number".to_string(),
                        },
                        optional: false,
                        default: None,
                        config: serde_json::json!({}),
                        entity_id: Some(2),
                    },
                    FieldDefinition {
                        name: "email".to_string(),
                        field_type: TypeExpression::Identifier {
                            name: "string".to_string(),
                        },
                        optional: false,
                        default: None,
                        config: serde_json::json!({}),
                        entity_id: Some(3),
                    },
                ],
                config: serde_json::json!({}),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        let deltas = vec![
            Delta::FieldAdded {
                model: "User".to_string(),
                field: "name".to_string(),
                after: FieldDefinition {
                    name: "name".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: None,
                    config: serde_json::json!({}),
                    entity_id: Some(4),
                },
            },
            Delta::FieldRemoved {
                model: "User".to_string(),
                field: "email".to_string(),
                before: FieldDefinition {
                    name: "email".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: None,
                    config: serde_json::json!({}),
                    entity_id: Some(3),
                },
            },
        ];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Up migration should have both operations
        assert!(files[0].content.contains("ADD COLUMN"));
        assert!(files[0].content.contains("DROP COLUMN"));

        // Down migration should reverse both operations
        assert!(files[1].content.contains("DROP COLUMN \"name\""));
        assert!(files[1].content.contains("ADD COLUMN \"email\""));
    }

    #[test]
    fn test_migrate_file_naming() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let deltas = vec![Delta::ModelAdded {
            name: "User".to_string(),
            after: ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({}),
            },
        }];

        // Test PostgreSQL file naming
        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;
        let files = migrate(schema.clone(), deltas.clone(), config, &utils);
        assert_eq!(files[0].path, "001_migration.up.postgres.sql");
        assert_eq!(files[1].path, "001_migration.down.postgres.sql");

        // Test SQLite file naming
        let config = serde_json::json!({ "dialect": "sqlite", "pluralize_table_names": false });
        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files[0].path, "001_migration.up.sqlite.sql");
        assert_eq!(files[1].path, "001_migration.down.sqlite.sql");
    }

    #[test]
    fn test_migrate_model_with_indexes_added() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let deltas = vec![Delta::ModelAdded {
            name: "User".to_string(),
            after: ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({
                    "indexes": [
                        {
                            "fields": ["email"],
                            "unique": true
                        },
                        {
                            "fields": ["created_at"]
                        }
                    ]
                }),
            },
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check up migration
        let expected_up = "-- Migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

CREATE TABLE \"user\" (
  UNIQUE (\"email\")
);

CREATE INDEX \"idx_user_1\" ON \"user\" (\"created_at\");

";
        assert_eq!(files[0].content, expected_up);

        // Check down migration
        let expected_down = "-- Rollback migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

DROP TABLE \"user\";

";
        assert_eq!(files[1].content, expected_down);
    }

    #[test]
    fn test_migrate_model_with_primary_key_added() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let deltas = vec![Delta::ModelAdded {
            name: "User".to_string(),
            after: ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({
                    "indexes": [
                        {
                            "fields": ["id"],
                            "primary": true
                        }
                    ]
                }),
            },
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check up migration
        let expected_up = "-- Migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

CREATE TABLE \"user\" (
  PRIMARY KEY (\"id\")
);

";
        assert_eq!(files[0].content, expected_up);

        // Check down migration
        let expected_down = "-- Rollback migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

DROP TABLE \"user\";

";
        assert_eq!(files[1].content, expected_down);
    }

    #[test]
    fn test_migrate_model_with_composite_index_added() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let deltas = vec![Delta::ModelAdded {
            name: "Post".to_string(),
            after: ModelDefinition {
                name: "Post".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({
                    "indexes": [
                        {
                            "name": "idx_user_created",
                            "fields": ["user_id", "created_at"]
                        }
                    ]
                }),
            },
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check up migration
        let expected_up = "-- Migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

CREATE TABLE \"post\" (
);

CREATE INDEX \"idx_user_created\" ON \"post\" (\"user_id\", \"created_at\");

";
        assert_eq!(files[0].content, expected_up);

        // Check down migration
        let expected_down = "-- Rollback migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

DROP TABLE \"post\";

";
        assert_eq!(files[1].content, expected_down);
    }

    #[test]
    fn test_migrate_model_with_partial_index_postgres() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let deltas = vec![Delta::ModelAdded {
            name: "User".to_string(),
            after: ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({
                    "indexes": [
                        {
                            "name": "idx_active_users",
                            "fields": ["email"],
                            "where": "active = TRUE"
                        }
                    ]
                }),
            },
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check up migration
        let expected_up = "-- Migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

CREATE TABLE \"user\" (
);

CREATE INDEX \"idx_active_users\" ON \"user\" (\"email\") WHERE active = TRUE;

";
        assert_eq!(files[0].content, expected_up);

        // Check down migration
        let expected_down = "-- Rollback migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

DROP TABLE \"user\";

";
        assert_eq!(files[1].content, expected_down);
    }

    #[test]
    fn test_migrate_model_with_index_method_postgres() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let deltas = vec![Delta::ModelAdded {
            name: "Document".to_string(),
            after: ModelDefinition {
                name: "Document".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({
                    "indexes": [
                        {
                            "name": "idx_content_gin",
                            "fields": ["content"],
                            "method": "gin"
                        }
                    ]
                }),
            },
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check up migration
        let expected_up = "-- Migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

CREATE TABLE \"document\" (
);

CREATE INDEX \"idx_content_gin\" ON \"document\" (\"content\") USING GIN;

";
        assert_eq!(files[0].content, expected_up);

        // Check down migration
        let expected_down = "-- Rollback migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

DROP TABLE \"document\";

";
        assert_eq!(files[1].content, expected_down);
    }

    #[test]
    fn test_migrate_model_with_multiple_constraint_types() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let deltas = vec![Delta::ModelAdded {
            name: "User".to_string(),
            after: ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({
                    "indexes": [
                        {
                            "fields": ["id"],
                            "primary": true
                        },
                        {
                            "fields": ["email"],
                            "unique": true
                        },
                        {
                            "fields": ["username"],
                            "unique": true
                        },
                        {
                            "fields": ["created_at"]
                        }
                    ]
                }),
            },
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check up migration
        let expected_up = "-- Migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

CREATE TABLE \"user\" (
  PRIMARY KEY (\"id\"),
  UNIQUE (\"email\"),
  UNIQUE (\"username\")
);

CREATE INDEX \"idx_user_3\" ON \"user\" (\"created_at\");

";
        assert_eq!(files[0].content, expected_up);

        // Check down migration
        let expected_down = "-- Rollback migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

DROP TABLE \"user\";

";
        assert_eq!(files[1].content, expected_down);
    }

    #[test]
    fn test_migrate_model_config_changed_indexes() {
        use cdm_plugin_interface::TypeExpression;

        let mut models = HashMap::new();
        models.insert(
            "User".to_string(),
            ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![FieldDefinition {
                    name: "email".to_string(),
                    field_type: TypeExpression::Identifier {
                        name: "string".to_string(),
                    },
                    optional: false,
                    default: None,
                    config: serde_json::json!({}),
                    entity_id: Some(2),
                }],
                config: serde_json::json!({
                    "indexes": [
                        {
                            "fields": ["email"],
                            "unique": true
                        }
                    ]
                }),
            },
        );

        let schema = Schema {
            type_aliases: HashMap::new(),
            models,
        };

        // Simulate config change (indexes added/removed/modified)
        let deltas = vec![Delta::ModelConfigChanged {
            model: "User".to_string(),
            before: serde_json::json!({}),
            after: serde_json::json!({
                "indexes": [
                    {
                        "fields": ["email"],
                        "unique": true
                    }
                ]
            }),
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check that config changes generate migration files
        let up_content = &files[0].content;
        assert!(up_content.contains("-- Model config changed: User"));
    }

    #[test]
    fn test_migrate_sqlite_indexes() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let deltas = vec![Delta::ModelAdded {
            name: "User".to_string(),
            after: ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({
                    "indexes": [
                        {
                            "fields": ["id"],
                            "primary": true
                        },
                        {
                            "fields": ["email"],
                            "unique": true
                        },
                        {
                            "fields": ["created_at"]
                        }
                    ]
                }),
            },
        }];

        let config = serde_json::json!({ "dialect": "sqlite", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check SQLite-specific syntax
        let up_content = &files[0].content;
        assert!(up_content.contains("CREATE TABLE \"user\""));
        assert!(up_content.contains("PRIMARY KEY"));
        assert!(up_content.contains("UNIQUE"));
        assert!(up_content.contains("CREATE INDEX"));

        // SQLite should not have WHERE clause support in this context
        assert!(!up_content.contains("WHERE"));
    }

    #[test]
    fn test_migrate_model_removed_with_indexes() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let deltas = vec![Delta::ModelRemoved {
            name: "User".to_string(),
            before: ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({
                    "indexes": [
                        {
                            "fields": ["id"],
                            "primary": true
                        },
                        {
                            "name": "idx_email",
                            "fields": ["email"]
                        }
                    ]
                }),
            },
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Up migration should drop table (and all indexes with it)
        let up_content = &files[0].content;
        assert!(up_content.contains("DROP TABLE"));

        // Down migration should recreate table with indexes
        let down_content = &files[1].content;
        assert!(down_content.contains("CREATE TABLE"));
        assert!(down_content.contains("PRIMARY KEY"));
        assert!(down_content.contains("CREATE INDEX"));
        assert!(down_content.contains("\"idx_email\""));
    }

    #[test]
    fn test_migrate_composite_primary_key() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let deltas = vec![Delta::ModelAdded {
            name: "UserRole".to_string(),
            after: ModelDefinition {
                name: "UserRole".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({
                    "indexes": [
                        {
                            "fields": ["user_id", "role_id"],
                            "primary": true
                        }
                    ]
                }),
            },
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check up migration
        let expected_up = "-- Migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

CREATE TABLE \"user_role\" (
  PRIMARY KEY (\"user_id\", \"role_id\")
);

";
        assert_eq!(files[0].content, expected_up);

        // Check down migration
        let expected_down = "-- Rollback migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

DROP TABLE \"user_role\";

";
        assert_eq!(files[1].content, expected_down);
    }

    #[test]
    fn test_migrate_composite_unique_constraint() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let deltas = vec![Delta::ModelAdded {
            name: "Product".to_string(),
            after: ModelDefinition {
                name: "Product".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({
                    "indexes": [
                        {
                            "fields": ["sku", "store_id"],
                            "unique": true
                        }
                    ]
                }),
            },
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check up migration
        let expected_up = "-- Migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

CREATE TABLE \"product\" (
  UNIQUE (\"sku\", \"store_id\")
);

";
        assert_eq!(files[0].content, expected_up);

        // Check down migration
        let expected_down = "-- Rollback migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

DROP TABLE \"product\";

";
        assert_eq!(files[1].content, expected_down);
    }

    #[test]
    fn test_migrate_with_schema_prefix_and_indexes() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let deltas = vec![Delta::ModelAdded {
            name: "User".to_string(),
            after: ModelDefinition {
                name: "User".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({
                    "indexes": [
                        {
                            "name": "idx_email",
                            "fields": ["email"]
                        }
                    ]
                }),
            },
        }];

        let config = serde_json::json!({
            "dialect": "postgresql",
            "schema": "public",
            "pluralize_table_names": false
        });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check up migration
        let expected_up = "-- Migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

CREATE TABLE \"public\".\"user\" (
);

CREATE INDEX \"idx_email\" ON \"public\".\"user\" (\"email\");

";
        assert_eq!(files[0].content, expected_up);

        // Check down migration
        let expected_down = "-- Rollback migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

DROP TABLE \"public\".\"user\";

";
        assert_eq!(files[1].content, expected_down);
    }

    #[test]
    fn test_migrate_multiple_indexes_different_types() {
        let schema = Schema {
            type_aliases: HashMap::new(),
            models: HashMap::new(),
        };

        let deltas = vec![Delta::ModelAdded {
            name: "Document".to_string(),
            after: ModelDefinition {
                name: "Document".to_string(),
                entity_id: Some(1),
                parents: vec![],
                fields: vec![],
                config: serde_json::json!({
                    "indexes": [
                        {
                            "fields": ["id"],
                            "primary": true
                        },
                        {
                            "name": "idx_title",
                            "fields": ["title"]
                        },
                        {
                            "name": "idx_content_gin",
                            "fields": ["content"],
                            "method": "gin"
                        },
                        {
                            "name": "idx_published",
                            "fields": ["published_at"],
                            "where": "published_at IS NOT NULL"
                        }
                    ]
                }),
            },
        }];

        let config = serde_json::json!({ "dialect": "postgresql", "pluralize_table_names": false });
        let utils = Utils;

        let files = migrate(schema, deltas, config, &utils);
        assert_eq!(files.len(), 2);

        // Check up migration
        let expected_up = "-- Migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

CREATE TABLE \"document\" (
  PRIMARY KEY (\"id\")
);

CREATE INDEX \"idx_title\" ON \"document\" (\"title\");
CREATE INDEX \"idx_content_gin\" ON \"document\" (\"content\") USING GIN;
CREATE INDEX \"idx_published\" ON \"document\" (\"published_at\") WHERE published_at IS NOT NULL;

";
        assert_eq!(files[0].content, expected_up);

        // Check down migration
        let expected_down = "-- Rollback migration generated by CDM SQL Plugin
-- Dialect: PostgreSQL

DROP TABLE \"document\";

";
        assert_eq!(files[1].content, expected_down);
    }
}
