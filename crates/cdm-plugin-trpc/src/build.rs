use cdm_plugin_interface::{OutputFile, Schema, Utils, JSON};
use std::collections::BTreeSet;

use crate::validate::{collect_model_references, is_array_output, is_void_output, strip_array_suffix};

/// Import configuration for schema imports
#[derive(Debug, Clone)]
struct ImportConfig {
    strategy: String,
    path: String,
}

impl ImportConfig {
    fn from_json(json: Option<&JSON>, default_path: &str) -> Self {
        match json {
            Some(config) => Self {
                strategy: config
                    .get("strategy")
                    .and_then(|v| v.as_str())
                    .unwrap_or("single")
                    .to_string(),
                path: config
                    .get("path")
                    .and_then(|v| v.as_str())
                    .unwrap_or(default_path)
                    .to_string(),
            },
            None => Self {
                strategy: "single".to_string(),
                path: default_path.to_string(),
            },
        }
    }

    fn is_per_model(&self) -> bool {
        self.strategy == "per_model"
    }
}

/// Parsed procedure configuration for code generation
#[derive(Debug, Clone)]
struct Procedure {
    name: String,
    procedure_type: String,
    input: Option<String>,
    output: String,
    #[allow(dead_code)] // Reserved for future error handling features
    error: Option<String>,
}

/// Output type for a procedure
#[derive(Debug, Clone)]
enum OutputType {
    /// Single model reference (e.g., "User")
    Single(String),
    /// Array of models (e.g., "User[]")
    Array(String),
    /// No output (void)
    Void,
}

/// Generates tRPC router contract from the schema
pub fn build(schema: Schema, config: JSON, _utils: &Utils) -> Vec<OutputFile> {
    // Note: build_output is handled by CDM, not by plugins.
    // Plugins return relative paths; CDM prepends the output directory.

    // Parse import configuration
    let schema_import = ImportConfig::from_json(config.get("schema_import"), "./types");

    let procedures_config = match config.get("procedures") {
        Some(p) => p,
        None => return vec![],
    };

    // Parse procedures from config
    let procedures = parse_procedures(procedures_config);
    if procedures.is_empty() {
        return vec![];
    }

    // Collect all model references for imports
    let model_refs = collect_model_references(procedures_config);

    // Get valid models from schema (models + type aliases)
    let valid_models: std::collections::HashSet<String> = schema
        .models
        .keys()
        .cloned()
        .chain(schema.type_aliases.keys().cloned())
        .collect();

    // Generate the contract file
    let content = generate_contract(&procedures, &model_refs, &valid_models, &schema_import);

    vec![OutputFile {
        path: "contract.ts".to_string(),
        content,
    }]
}

fn parse_procedures(procedures_config: &JSON) -> Vec<Procedure> {
    let mut procedures = Vec::new();

    if let Some(procedures_obj) = procedures_config.as_object() {
        for (procedure_name, procedure_config) in procedures_obj {
            if let Some(procedure) = parse_procedure(procedure_name, procedure_config) {
                procedures.push(procedure);
            }
        }
    }

    // Sort procedures by name for consistent output
    procedures.sort_by(|a, b| a.name.cmp(&b.name));
    procedures
}

fn parse_procedure(name: &str, config: &JSON) -> Option<Procedure> {
    let procedure_type = config.get("type")?.as_str()?.to_lowercase();
    let output = config.get("output")?.as_str()?.to_string();

    let input = config
        .get("input")
        .and_then(|v| v.as_str())
        .map(String::from);
    let error = config
        .get("error")
        .and_then(|v| v.as_str())
        .map(String::from);

    Some(Procedure {
        name: name.to_string(),
        procedure_type,
        input,
        output,
        error,
    })
}

fn parse_output_type(output: &str) -> OutputType {
    if is_void_output(output) {
        OutputType::Void
    } else if is_array_output(output) {
        OutputType::Array(strip_array_suffix(output).to_string())
    } else {
        OutputType::Single(output.to_string())
    }
}

fn generate_contract(
    procedures: &[Procedure],
    _model_refs: &std::collections::HashSet<String>,
    valid_models: &std::collections::HashSet<String>,
    schema_import: &ImportConfig,
) -> String {
    let mut output = String::new();

    // Header comment
    output.push_str("/**\n");
    output.push_str(" * Generated by CDM @trpc plugin\n");
    output.push_str(" * DO NOT EDIT - changes will be overwritten\n");
    output.push_str(" */\n\n");

    // Import tRPC
    output.push_str("import { initTRPC } from '@trpc/server';\n");

    // Check if we need observable import (for subscriptions)
    let has_subscriptions = procedures
        .iter()
        .any(|p| p.procedure_type == "subscription");
    if has_subscriptions {
        output.push_str("import { observable } from '@trpc/server/observable';\n");
    }

    output.push_str("import { z } from 'zod';\n");

    // Generate schema imports
    let schema_imports_str = generate_schema_imports(procedures, valid_models, schema_import);
    if !schema_imports_str.is_empty() {
        output.push_str(&schema_imports_str);
    }

    output.push('\n');

    // Initialize tRPC with context placeholder
    output.push_str("// Initialize tRPC - replace TContext with your context type\n");
    output.push_str("type TContext = Record<string, unknown>;\n");
    output.push_str("const t = initTRPC.context<TContext>().create();\n\n");

    // Procedure builders
    output.push_str("// Procedure builders\n");
    output.push_str("const router = t.router;\n");
    output.push_str("const publicProcedure = t.procedure;\n\n");

    // Generate router definition
    output.push_str("// Router definition - implement handlers in your server code\n");
    output.push_str("export const appRouter = router({\n");

    for (i, procedure) in procedures.iter().enumerate() {
        output.push_str(&generate_procedure(procedure, valid_models));
        if i < procedures.len() - 1 {
            output.push('\n');
        }
    }

    output.push_str("});\n\n");

    // Export router type
    output.push_str("// Export router type for client usage\n");
    output.push_str("export type AppRouter = typeof appRouter;\n");

    output
}

fn generate_schema_imports(
    procedures: &[Procedure],
    valid_models: &std::collections::HashSet<String>,
    schema_import: &ImportConfig,
) -> String {
    // Collect all model names that need schema imports
    let mut models: BTreeSet<String> = BTreeSet::new();

    for procedure in procedures {
        if let Some(ref input) = procedure.input {
            let model = strip_array_suffix(input);
            if valid_models.contains(model) {
                models.insert(model.to_string());
            }
        }

        if !is_void_output(&procedure.output) {
            let model = strip_array_suffix(&procedure.output);
            if valid_models.contains(model) {
                models.insert(model.to_string());
            }
        }

        if let Some(ref error) = procedure.error {
            let model = strip_array_suffix(error);
            if valid_models.contains(model) {
                models.insert(model.to_string());
            }
        }
    }

    if models.is_empty() {
        return String::new();
    }

    if schema_import.is_per_model() {
        // Per-model strategy: generate separate imports for each model
        models
            .iter()
            .map(|model| {
                format!(
                    "import {{ {}Schema }} from '{}/{}';\n",
                    model, schema_import.path, model
                )
            })
            .collect::<Vec<_>>()
            .join("")
    } else {
        // Single file strategy: generate one import with all schemas
        let schema_names: Vec<String> = models
            .iter()
            .map(|m| format!("  {}Schema,", m))
            .collect();
        format!(
            "import {{\n{}\n}} from '{}';\n",
            schema_names.join("\n"),
            schema_import.path
        )
    }
}

fn generate_procedure(
    procedure: &Procedure,
    valid_models: &std::collections::HashSet<String>,
) -> String {
    let mut output = String::new();

    output.push_str(&format!("  {}: publicProcedure\n", procedure.name));

    // Input schema
    if let Some(ref input) = procedure.input {
        let input_schema = format_schema(input, valid_models);
        output.push_str(&format!("    .input({})\n", input_schema));
    }

    // Output schema
    let output_type = parse_output_type(&procedure.output);
    let output_schema = format_output_schema(&output_type, valid_models);
    output.push_str(&format!("    .output({})\n", output_schema));

    // Procedure type with handler
    match procedure.procedure_type.as_str() {
        "query" => {
            output.push_str(&generate_query_handler(procedure, &output_type));
        }
        "mutation" => {
            output.push_str(&generate_mutation_handler(procedure, &output_type));
        }
        "subscription" => {
            output.push_str(&generate_subscription_handler(procedure, &output_type));
        }
        _ => {
            // Fallback to query for unknown types
            output.push_str(&generate_query_handler(procedure, &output_type));
        }
    }

    output
}

fn generate_query_handler(procedure: &Procedure, output_type: &OutputType) -> String {
    let has_input = procedure.input.is_some();
    let params = if has_input { "{ input, ctx }" } else { "{ ctx }" };
    let return_comment = generate_return_comment(output_type, &procedure.output);

    format!(
        "    .query(({}) => {{\n      // Implement: return {}\n      throw new Error('Not implemented');\n    }}),\n",
        params, return_comment
    )
}

fn generate_mutation_handler(procedure: &Procedure, output_type: &OutputType) -> String {
    let has_input = procedure.input.is_some();
    let params = if has_input { "{ input, ctx }" } else { "{ ctx }" };
    let return_comment = generate_return_comment(output_type, &procedure.output);

    format!(
        "    .mutation(({}) => {{\n      // Implement: return {}\n      throw new Error('Not implemented');\n    }}),\n",
        params, return_comment
    )
}

fn generate_subscription_handler(procedure: &Procedure, output_type: &OutputType) -> String {
    let has_input = procedure.input.is_some();
    let params = if has_input { "{ input, ctx }" } else { "{ ctx }" };
    let emit_type = match output_type {
        OutputType::Single(model) => model.clone(),
        OutputType::Array(model) => format!("{}[]", model),
        OutputType::Void => "void".to_string(),
    };

    format!(
        "    .subscription(({}) => {{\n      return observable<{}>(emit => {{\n        // Implement: emit.next(value) when data is available\n        return () => {{ /* cleanup */ }};\n      }});\n    }}),\n",
        params, emit_type
    )
}

fn generate_return_comment(output_type: &OutputType, original_output: &str) -> String {
    match output_type {
        OutputType::Void => "void".to_string(),
        OutputType::Single(_) | OutputType::Array(_) => original_output.to_string(),
    }
}

fn format_schema(model_name: &str, valid_models: &std::collections::HashSet<String>) -> String {
    let is_array = is_array_output(model_name);
    let base_model = strip_array_suffix(model_name);

    let schema = if valid_models.contains(base_model) {
        format!("{}Schema", base_model)
    } else {
        // If model not found, use z.unknown() as fallback
        "z.unknown()".to_string()
    };

    if is_array {
        format!("z.array({})", schema)
    } else {
        schema
    }
}

fn format_output_schema(
    output_type: &OutputType,
    valid_models: &std::collections::HashSet<String>,
) -> String {
    match output_type {
        OutputType::Void => "z.void()".to_string(),
        OutputType::Single(model) => {
            if valid_models.contains(model) {
                format!("{}Schema", model)
            } else {
                "z.unknown()".to_string()
            }
        }
        OutputType::Array(model) => {
            if valid_models.contains(model) {
                format!("z.array({}Schema)", model)
            } else {
                "z.array(z.unknown())".to_string()
            }
        }
    }
}

#[cfg(test)]
#[path = "build/build_tests.rs"]
mod build_tests;
