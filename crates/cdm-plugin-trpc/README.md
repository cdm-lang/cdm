# CDM tRPC Plugin

Generate type-safe [tRPC](https://trpc.io/) router contracts from your CDM models.

## Overview

The tRPC plugin generates a type-safe router contract that can be used for both server implementations and client consumption. The generated contract provides end-to-end type safety for procedures including input validation, output types, and procedure types (query, mutation, subscription).

## Dependencies

This plugin requires the `@typescript` plugin to be configured:

| Plugin | Required | Purpose |
|--------|----------|---------|
| `@typescript` | Yes | Generates TypeScript interfaces and Zod schemas (with `generate_zod: true`) |

The `@trpc` plugin must be listed **after** the `@typescript` plugin in the CDM file to ensure its outputs are available.

**Note:** Enable `generate_zod: true` in the `@typescript` plugin configuration to generate Zod schemas that the tRPC contract will import.

## Installation

Configure the plugin in your CDM file:

```cdm
@typescript {
  build_output: "./generated",
  generate_zod: true
}

@trpc {
  build_output: "./generated",
  procedures: {
    // Procedure definitions here
  }
}
```

## Quick Start

```cdm
@typescript {
  build_output: "./generated",
  generate_zod: true
}

@trpc {
  build_output: "./generated",
  procedures: {
    getUser: {
      type: "query",
      input: "GetUserInput",
      output: "User"
    },
    listUsers: {
      type: "query",
      output: "User[]"
    },
    createUser: {
      type: "mutation",
      input: "CreateUserInput",
      output: "User"
    },
    deleteUser: {
      type: "mutation",
      input: "DeleteUserInput",
      output: "void"
    },
    onUserCreated: {
      type: "subscription",
      output: "User"
    }
  }
}

// Input types
GetUserInput { id: string }
CreateUserInput { email: string, name: string }
DeleteUserInput { id: string }

// Output types
User { id: string, email: string, name: string }
```

**Generated Contract (`./generated/contract.ts`):**

```typescript
/**
 * Generated by CDM @trpc plugin
 * DO NOT EDIT - changes will be overwritten
 */

import { initTRPC } from '@trpc/server';
import { observable } from '@trpc/server/observable';
import { z } from 'zod';
import {
  type User,
  CreateUserInputSchema,
  DeleteUserInputSchema,
  GetUserInputSchema,
  UserSchema,
} from './types';

// Initialize tRPC - replace TContext with your context type
type TContext = Record<string, unknown>;
const t = initTRPC.context<TContext>().create();

// Procedure builders
const router = t.router;
const publicProcedure = t.procedure;

// Router definition - implement handlers in your server code
export const appRouter = router({
  createUser: publicProcedure
    .input(CreateUserInputSchema)
    .output(UserSchema)
    .mutation(({ input: _input, ctx: _ctx }) => {
      // TODO: Implement - return User
      throw new Error('Not implemented');
    }),

  deleteUser: publicProcedure
    .input(DeleteUserInputSchema)
    .output(z.void())
    .mutation(({ input: _input, ctx: _ctx }) => {
      // TODO: Implement - return void
      throw new Error('Not implemented');
    }),

  getUser: publicProcedure
    .input(GetUserInputSchema)
    .output(UserSchema)
    .query(({ input: _input, ctx: _ctx }) => {
      // TODO: Implement - return User
      throw new Error('Not implemented');
    }),

  listUsers: publicProcedure
    .output(z.array(UserSchema))
    .query(({ ctx: _ctx }) => {
      // TODO: Implement - return User[]
      throw new Error('Not implemented');
    }),

  onUserCreated: publicProcedure
    .output(UserSchema)
    .subscription(({ ctx: _ctx }) => {
      return observable<User>(_emit => {
        // TODO: Implement - call _emit.next(value) when data is available
        return () => { /* cleanup */ };
      });
    }),
});

// Export router type for client usage
export type AppRouter = typeof appRouter;
```

## Global Settings

Configure the plugin at import time.

> **Note:** `build_output` is a CDM-level setting, not a plugin setting. Configure it at the plugin import but it is processed by CDM, not the plugin. See CDM documentation for details.

### `procedures` (required)

- **Type:** `object`
- **Description:** Map of procedure name to procedure configuration.

```cdm
@trpc {
  procedures: {
    procedureName: {
      type: "query",
      input: "InputModel",
      output: "OutputModel"
    }
  }
}
```

### `schema_import`

- **Type:** `object` (optional)
- **Description:** Configuration for importing Zod schemas from the TypeScript plugin.

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `strategy` | `"single" \| "per_model"` | `"single"` | How the TypeScript plugin organizes schema files |
| `path` | `string` | `"./types"` | For `single`: file path without extension. For `per_model`: directory path |

```cdm
// For TypeScript plugin with file_strategy: "single"
@trpc {
  schema_import: {
    strategy: "single",
    path: "./types"
  }
}

// For TypeScript plugin with file_strategy: "per_model"
@trpc {
  schema_import: {
    strategy: "per_model",
    path: "./models"
  }
}
```

## Procedure Configuration

Each procedure in the `procedures` object supports the following fields:

### `type` (required)

- **Type:** `"query" | "mutation" | "subscription"`
- **Description:** The type of tRPC procedure.

| Type | Description |
|------|-------------|
| `query` | Read-only operations that fetch data |
| `mutation` | Operations that modify data |
| `subscription` | Real-time streaming operations |

### `input`

- **Type:** `string` (optional)
- **Description:** Model name for input validation. If omitted, the procedure accepts no input.

```cdm
getUser: {
  type: "query",
  input: "GetUserInput",  // References a CDM model
  output: "User"
}
```

### `output` (required)

- **Type:** `string`
- **Description:** Model name for output type, or special values.

#### Output Value Types

| Type | Example | Description |
|------|---------|-------------|
| String | `"User"` | Single model response |
| String with `[]` | `"User[]"` | Array response |
| `"void"` | `"void"` | No return value |

```cdm
// Single model output
getUser: { type: "query", output: "User" }

// Array output
listUsers: { type: "query", output: "User[]" }

// Void output (for mutations that don't return data)
deleteUser: { type: "mutation", input: "DeleteUserInput", output: "void" }
```

### `error`

- **Type:** `string` (optional)
- **Description:** Error type name (reserved for future error handling features).

## Validation Rules

The plugin validates your configuration and reports errors:

### Errors

| Rule | Message |
|------|---------|
| procedures required | `procedures` is required |
| procedures empty | `procedures` must contain at least one procedure |
| type required | Procedure is missing required field `type` |
| type invalid | Invalid procedure type (must be query, mutation, or subscription) |
| output required | Procedure is missing required field `output` |
| output invalid | output must be a string |
| input invalid | input must be a string |
| error invalid | error must be a string |

## Usage Examples

### Server Implementation

```typescript
import { createHTTPServer } from '@trpc/server/adapters/standalone';
import { appRouter, type AppRouter } from './generated/contract';
import { db } from './db';

// Create context for each request
const createContext = () => ({
  db,
  user: null, // Add authentication here
});

// Override the generated router with actual implementations
const router = {
  ...appRouter,
  getUser: appRouter.getUser.resolve(async ({ input, ctx }) => {
    const user = await ctx.db.users.findById(input.id);
    if (!user) {
      throw new TRPCError({ code: 'NOT_FOUND' });
    }
    return user;
  }),
  // ... implement other procedures
};

const server = createHTTPServer({
  router,
  createContext,
});

server.listen(3000);
```

### Client Usage

```typescript
import { createTRPCClient, httpBatchLink } from '@trpc/client';
import type { AppRouter } from './generated/contract';

const client = createTRPCClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000',
    }),
  ],
});

// Fully typed request and response
const user = await client.getUser.query({ id: '123' });
console.log(user.email); // TypeScript knows this is a User

const users = await client.listUsers.query();
users.forEach(u => console.log(u.name)); // Array of Users

await client.createUser.mutate({ email: 'new@example.com', name: 'New User' });
```

### React Query Integration

```typescript
import { createTRPCReact } from '@trpc/react-query';
import type { AppRouter } from './generated/contract';

export const trpc = createTRPCReact<AppRouter>();

function UserList() {
  const { data: users, isLoading } = trpc.listUsers.useQuery();

  if (isLoading) return <div>Loading...</div>;

  return (
    <ul>
      {users?.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

function CreateUserForm() {
  const utils = trpc.useUtils();
  const createUser = trpc.createUser.useMutation({
    onSuccess: () => {
      utils.listUsers.invalidate();
    },
  });

  const handleSubmit = (data: CreateUserInput) => {
    createUser.mutate(data);
  };

  // ...
}
```

### Subscription Example

```typescript
// Server-side implementation
import { observable } from '@trpc/server/observable';

const userEvents = new EventEmitter();

// In your actual implementation
onUserCreated: publicProcedure
  .output(UserSchema)
  .subscription(() => {
    return observable<User>(emit => {
      const onUser = (user: User) => emit.next(user);
      userEvents.on('created', onUser);
      return () => userEvents.off('created', onUser);
    });
  }),

// Client-side usage
const subscription = client.onUserCreated.subscribe(undefined, {
  onData: (user) => {
    console.log('New user created:', user);
  },
});

// Cleanup
subscription.unsubscribe();
```

## Configuring Import Paths

The `@trpc` plugin needs to know where to import Zod schemas from. This depends on how you configure the `@typescript` plugin.

### Single File Strategy (Default)

When the TypeScript plugin uses `file_strategy: "single"` (the default), all types and schemas are in one file:

```cdm
@typescript {
  build_output: "./generated",
  file_strategy: "single",
  single_file_name: "types.ts",
  generate_zod: true
}

@trpc {
  build_output: "./generated",
  schema_import: {
    strategy: "single",
    path: "./types"
  },
  procedures: { /* ... */ }
}
```

### Per-Model Strategy

When the TypeScript plugin uses `file_strategy: "per_model"`, each model gets its own file:

```cdm
@typescript {
  build_output: "./generated/models",
  file_strategy: "per_model",
  generate_zod: true
}

@trpc {
  build_output: "./generated",
  schema_import: {
    strategy: "per_model",
    path: "./models"
  },
  procedures: { /* ... */ }
}
```

**Generated output for per_model:**

```typescript
// contract.ts
import { initTRPC } from '@trpc/server';
import { z } from 'zod';
import { UserSchema } from './models/User';
import { GetUserInputSchema } from './models/GetUserInput';

// ... contract definition ...
```

## Output Files

The plugin generates a single file:

- **`{build_output}/contract.ts`** - tRPC router contract with all procedures

This file imports Zod schemas from the location configured via `schema_import` (default: `./types`). The schemas are generated by the `@typescript` plugin with `generate_zod: true`.

## CLI Commands

```bash
# Validate configuration
cdm validate schema.cdm

# Generate contract
cdm build schema.cdm
```

---

## Development

### Building

```bash
# Build the plugin (release mode)
make build

# Build in debug mode (faster compilation)
make build-debug

# See all available commands
make help
```

### Testing

```bash
# Run all tests
make test

# Run unit tests only
make test-unit
```

### Local Testing

Use this plugin from any CDM file with a relative path:

```cdm
@trpc from "./path/to/cdm-plugin-trpc" {
  build_output: "./generated",
  procedures: { /* ... */ }
}
```

## License

See the main CDM repository for license information.
