# 1. Core Concepts

This section explains the foundational ideas behind CDM. Understanding these concepts will make the rest of the documentation—especially [contexts](3-context-system.md), [plugins](4-plugins-and-code-generation.md), and [migrations](5-cli-usage-and-workflows.md#53-migration-workflow)—much easier to reason about.

---

## 1.1 Schemas as a Single Source of Truth

At its core, CDM is about **eliminating duplication**.

In a typical system, the same data model is redefined multiple times:

* Database schemas
* ORM models
* API request/response types
* Client-side types
* Validation rules
* Migration logic

Each definition is slightly different, and over time they drift.

CDM replaces this pattern with a single, authoritative schema. All downstream representations—SQL, TypeScript, validation, documentation—are generated from that schema.

This has two important consequences:

1. **The schema becomes the contract**, not generated code
2. **Changes are intentional and explicit**, not inferred

CDM is designed so that the schema is the most carefully reviewed artifact in the system.

---

## 1.2 Types, Models, and Fields

CDM schemas are built from a small set of core building blocks.

### Type Aliases

A **type alias** gives a name to a type expression.

```cdm
Email: string
Status: "active" | "pending" | "disabled"
```

Type aliases:

* Improve readability
* Encourage reuse
* Carry plugin configuration
* Can be overridden in contexts

Aliases are resolved at build time and do not exist at runtime unless generated by a plugin.

---

### Models

A **model** is a structured type with named fields.

```cdm
User {
  id: string
  email: Email
  status: Status
}
```

Models are typically used to represent entities such as users, posts, or orders. They can reference other models, forming relationships.

Models can also:

* Extend other models
* Be modified by contexts
* Carry plugin configuration

---

### Fields

Fields define the shape of a model.

```cdm
User {
  name: string
  nickname?: string
  role: "admin" | "member" = "member"
}
```

A field may have:

* A type
* Optionality
* A default value
* Plugin-specific configuration
* A stable entity ID

If no type is specified, the field defaults to `string`.

---

## 1.3 [Contexts](3-context-system.md)

A **context** represents a specific view of a schema.

Instead of copying schemas for different environments (database, API, client), CDM allows you to **extend and modify** an existing schema.

```cdm
// api.cdm
extends ./base.cdm

User {
  -password_hash
}
```

Contexts can:

* Add new models or types
* Remove models or types
* Modify existing models
* Override type aliases
* Change plugin configuration

Contexts are resolved by applying changes layer by layer, starting from a base schema and moving outward.

This makes differences between environments explicit and reviewable.

---

## 1.4 Entity IDs and Schema Evolution

One of CDM’s most important features is **stable entity IDs**.

Entity IDs are optional numeric identifiers assigned to:

* Models
* Type aliases
* Fields

```cdm
User {
  name: string #1
} #10
```

### Why Entity IDs Matter

Without IDs, schema tools must *guess* whether a change is a rename or a removal:

* Was `name` renamed to `display_name`?
* Or was `name` deleted and `display_name` added?

With entity IDs, CDM knows.

```cdm
User {
  display_name: string #1
}
```

Because the ID stayed the same, CDM treats this as a rename and preserves data in migrations.

Use the [format command](5-cli-usage-and-workflows.md#assigning-entity-ids) to automatically add entity IDs to your cdm files.

---

### ID Design Principles

* IDs should be **stable** and **never reused**
* IDs are optional, but strongly recommended for long-lived schemas
* Field IDs are scoped to their model
* Model and type IDs are global within a project

Entity IDs allow CDM to generate migrations that are deterministic and safe.

---

## 1.5 [Plugins](4-plugins-and-code-generation.md)

CDM itself does not generate SQL, TypeScript, or documentation.

Instead, all output is produced by **[plugins](4-plugins-and-code-generation.md)**.

Plugins:

* Consume the resolved schema
* Validate configuration
* Generate files
* Optionally generate migrations

Plugins run in a sandboxed environment and are configured directly in the schema.

```cdm
@typescript {
  build_output: "./generated"
}
```

Configuration can be applied at multiple levels:

* Globally
* Per type alias
* Per model
* Per field

This allows fine-grained control without duplicating schemas.

---

## 1.6 Validation and Build Phases

CDM processes schemas in distinct phases:

1. **Parsing** — syntax is parsed into a tree
2. **Resolution** — types, models, and contexts are resolved
3. **Semantic validation** — structural correctness is checked
4. **Plugin validation** — plugin-specific rules are enforced
5. **Build / migrate** — plugins generate output

If validation fails at any stage, generation does not proceed.

This ensures that generated code is always derived from a valid schema.

---

## 1.7 What CDM Deliberately Does Not Do

CDM is intentionally limited in scope.

It does **not**:

* Act as an ORM
* Execute at runtime
* Manage database connections
* Replace application logic
* Infer behavior implicitly

CDM’s job is to define structure, enforce correctness, and generate artifacts—nothing more.

---

## What's Next?

With the core concepts in place, explore the following topics:

* **[Templates](2-templates.md)** — reusable schema packages and type libraries
* **[Context System](3-context-system.md)** — how to create different views of your schema
* **[Plugins & Code Generation](4-plugins-and-code-generation.md)** — generating SQL, TypeScript, and more
* **[CLI Usage & Workflows](5-cli-usage-and-workflows.md)** — validation, builds, and migrations
* **[Reference](8-reference.md)** — detailed language syntax and CLI reference
