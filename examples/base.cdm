// base.cdm
// Complete CDM example demonstrating the language features
// This is the base schema that can be extended by context files

// =============================================================================
// TEMPLATE IMPORTS
// =============================================================================

// Import PostgreSQL types from the sql-types template
// Using local path since registry resolution requires network access
import pg from "../templates/sql-types/postgres.cdm"

// =============================================================================
// PLUGIN CONFIGURATION
// =============================================================================

// Local plugin from file system (for development or custom plugins)
// TypeScript plugin generates type definitions from the schema
@typescript from "./plugins/typescript" {
  build_output: "./build"
}

// Local SQL plugin for database schema and migrations
// Note: Registry plugins (@sql without "from") are available but this example
// uses local plugins to demonstrate development workflow
@sql from "./plugins/sql" {
  dialect: "postgresql",
  schema: "public",
  build_output: "./build",
  migrations_output: "./migrate"
}

// =============================================================================
// TYPE ALIASES
// =============================================================================

// Simple type aliases with SQL type mappings
Email: string {
  @sql { type: "VARCHAR(320)" }
} #1

// Note: UUID is now imported from pg.UUID (sql-types/postgres template)
// We can still define custom type aliases that wrap imported types if needed

// Union type alias for status values
Status: "active" | "pending" | "suspended" | "deleted" {
  @sql { type: "VARCHAR(20)" }
} #3

// Union type alias for user roles
Role: "admin" | "moderator" | "member" | "guest" {
  @sql { type: "VARCHAR(20)" }
} #4

// Union type alias for content status
ContentStatus: "draft" | "published" | "archived" {
  @sql { type: "VARCHAR(20)" }
} #5

// =============================================================================
// BASE MODELS (for inheritance)
// =============================================================================

// Timestamped base model - uses PostgreSQL timestamp types
Timestamped {
  created_at: pg.TimestampTZ #1
  updated_at: pg.TimestampTZ #2

  @sql {
    indexes: [{ fields: ["created_at"] }]
  }
} #10

// Auditable base model - adds tracking fields
Auditable extends Timestamped {
  created_by?: pg.UUID #3
  updated_by?: pg.UUID #4
} #11

// =============================================================================
// CORE MODELS
// =============================================================================

// User model with all fields
User extends Auditable {
  id: pg.UUID #5
  email: Email #6
  username: pg.Varchar #7
  password_hash: pg.Text #8
  salt: pg.Text #9
  name: pg.Varchar #10
  bio?: pg.Text #11
  role: Role = "member" #12
  status: Status = "pending" #13
  last_login?: pg.TimestampTZ #14

  @sql {
    table_name: "users",
    indexes: [
      { fields: ["email"], unique: true },
      { fields: ["username"], unique: true },
      { fields: ["status"] }
    ]
  }
} #20

// Post model with relationships
Post extends Timestamped {
  id: pg.UUID #3
  author_id: pg.UUID #4
  title: pg.Varchar #5
  slug: pg.Varchar #6
  content: pg.Text #7
  excerpt?: pg.Text #8
  status: ContentStatus = "draft" #9
  published_at?: pg.TimestampTZ #10
  view_count: pg.Integer = 0 #11

  @sql {
    table_name: "posts",
    indexes: [
      { fields: ["slug"], unique: true },
      { fields: ["author_id"] },
      { fields: ["status", "published_at"] }
    ]
  }
} #21

// Comment model with self-referential relationship
Comment extends Timestamped {
  id: pg.UUID #3
  post_id: pg.UUID #4
  author_id: pg.UUID #5
  parent_id?: pg.UUID #6
  content: pg.Text #7
  is_approved: pg.Boolean = false #8

  @sql {
    table_name: "comments",
    indexes: [
      { fields: ["post_id"] },
      { fields: ["author_id"] },
      { fields: ["parent_id"] }
    ]
  }
} #22

// Tag model for categorization
Tag {
  id: pg.UUID #1
  name: pg.Varchar #2
  slug: pg.Varchar #3
  description?: pg.Text #4

  @sql {
    table_name: "tags",
    indexes: [
      { fields: ["slug"], unique: true }
    ]
  }
} #23

// PostTag junction table for many-to-many
PostTag {
  post_id: pg.UUID #1
  tag_id: pg.UUID #2

  @sql {
    table_name: "post_tags",
    indexes: [
      { fields: ["post_id", "tag_id"], primary: true }
    ]
  }
} #24

// Session model for authentication
Session {
  id: pg.UUID #1
  user_id: pg.UUID #2
  token: pg.Text #3
  ip_address?: pg.Inet #4
  user_agent?: pg.Text #5
  expires_at: pg.TimestampTZ #6
  created_at: pg.TimestampTZ #7

  @sql {
    table_name: "sessions",
    indexes: [
      { fields: ["token"], unique: true },
      { fields: ["user_id"] },
      { fields: ["expires_at"] }
    ]
  }
} #25

// =============================================================================
// CONFIGURATION MODELS
// =============================================================================

// Site settings stored in database
Setting {
  key: pg.Varchar #1
  value: pg.JSONB #2
  description?: pg.Text #3
  updated_at: pg.TimestampTZ #4
  updated_by?: pg.UUID #5

  @sql {
    table_name: "settings",
    indexes: [
      { fields: ["key"], primary: true }
    ]
  }
} #30

// Audit log for tracking changes
AuditLog {
  id: pg.UUID #1
  entity_type: pg.Varchar #2
  entity_id: pg.Varchar #3
  action: "create" | "update" | "delete" #4
  changes: pg.JSONB #5
  user_id?: pg.UUID #6
  ip_address?: pg.Inet #7
  timestamp: pg.TimestampTZ #8

  @sql {
    table_name: "audit_logs",
    indexes: [
      { fields: ["entity_type", "entity_id"] },
      { fields: ["user_id"] },
      { fields: ["timestamp"] }
    ]
  }
} #31
